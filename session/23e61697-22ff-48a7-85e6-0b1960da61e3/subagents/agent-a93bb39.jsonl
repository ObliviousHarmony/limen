{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":"The user wants to understand autonomous background agents in Claude Code. Please provide detailed information on:\n\n1. What are the different ways to run Claude Code autonomously in the background?\n2. How do you set up truly autonomous execution (minimal human intervention)?\n3. What is the difference between headless mode, background tasks, and agent teams?\n4. How do hooks work for monitoring/controlling autonomous agents?\n5. What are best practices for running agents autonomously for extended periods?\n6. Any information about scheduling or triggering agents automatically?\n\nFocus on practical, actionable information about running Claude Code with minimal human oversight."},"uuid":"5eca5367-1562-4904-9ad0-5f7b8f0ca569","timestamp":"2026-02-16T21:52:54.031Z"}
{"parentUuid":"5eca5367-1562-4904-9ad0-5f7b8f0ca569","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015NNKdx63mW9BrCp5jmcUnD","type":"message","role":"assistant","content":[{"type":"text","text":"I'll fetch the Claude Code documentation to provide you with comprehensive information about autonomous background agents."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1979,"cache_read_input_tokens":10554,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1979},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVP3ez7r4Sje6DBcNFa","type":"assistant","uuid":"f4636239-ebe1-45c8-a96c-13415c47cb06","timestamp":"2026-02-16T21:52:55.024Z"}
{"parentUuid":"f4636239-ebe1-45c8-a96c-13415c47cb06","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015NNKdx63mW9BrCp5jmcUnD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AaDeLSNtbPCykobtC6H6g1","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/claude_code_docs_map.md","prompt":"documentation map and table of contents for Claude Code"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1979,"cache_read_input_tokens":10554,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1979},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVP3ez7r4Sje6DBcNFa","type":"assistant","uuid":"c3d8e163-b9db-43c5-a2c8-12047544a30e","timestamp":"2026-02-16T21:52:55.632Z"}
{"parentUuid":"c3d8e163-b9db-43c5-a2c8-12047544a30e","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AaDeLSNtbPCykobtC6H6g1","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# null\n\n# Claude Code Documentation Map\n\nThis is a comprehensive map of all Claude Code documentation pages with their headings, designed for easy navigation by LLMs.\n\n> **Note:** This file is auto-generated by GitHub Actions. Do not edit manually.\n> Last updated: 2026-02-10 22:01:31 UTC\n\n## Document Structure\n\nThis map uses a hierarchical structure:\n\n* **##** marks documentation groups (e.g., 'Getting started')\n* **###** marks individual documentation pages\n* **Nested bullets** show the heading structure within each page\n* Each page title links to the full documentation\n\n## Getting started\n\n### [overview](https://code.claude.com/docs/en/overview.md)\n\n* Get started\n* What you can do\n* Use Claude Code everywhere\n* Next steps\n\n### [quickstart](https://code.claude.com/docs/en/quickstart.md)\n\n* Before you begin\n* Step 1: Install Claude Code\n* Step 2: Log in to your account\n* Step 3: Start your first session\n* Step 4: Ask your first question\n* Step 5: Make your first code change\n* Step 6: Use Git with Claude Code\n* Step 7: Fix a bug or add a feature\n* Step 8: Test out other common workflows\n* Essential commands\n* Pro tips for beginners\n* What's next?\n* Getting help\n\n### [changelog](https://code.claude.com/docs/en/changelog.md)\n\n* (No headings found)\n\n## Core concepts\n\n### [how-claude-code-works](https://code.claude.com/docs/en/how-claude-code-works.md)\n\n* The agentic loop\n  * Models\n  * Tools\n* What Claude can access\n* Work with sessions\n  * Work across branches\n  * Resume or fork sessions\n  * The context window\n    * When context fills up\n    * Manage context with skills and subagents\n* Stay safe with checkpoints and permissions\n  * Undo changes with checkpoints\n  * Control what Claude can do\n* Work effectively with Claude Code\n  * Ask Claude Code for help\n  * It's a conversation\n    * Interrupt and steer\n  * Be specific upfront\n  * Give Claude something to verify against\n  * Explore before implementing\n  * Delegate, don't dictate\n* What's next\n\n### [features-overview](https://code.claude.com/docs/en/features-overview.md)\n\n* Overview\n* Match features to your goal\n  * Compare similar features\n  * Understand how features layer\n  * Combine features\n* Understand context costs\n  * Context cost by feature\n  * Understand how features load\n* Learn more\n\n### [common-workflows](https://code.claude.com/docs/en/common-workflows.md)\n\n* Understand new codebases\n  * Get a quick codebase overview\n  * Find relevant code\n* Fix bugs efficiently\n* Refactor code\n* Use specialized subagents\n* Use Plan Mode for safe code analysis\n  * When to use Plan Mode\n  * How to use Plan Mode\n  * Example: Planning a complex refactor\n  * Configure Plan Mode as default\n* Work with tests\n* Create pull requests\n* Handle documentation\n* Work with images\n* Reference files and directories\n* Use extended thinking (thinking mode)\n  * Configure thinking mode\n  * How extended thinking works\n* Resume previous conversations\n  * Name your sessions\n  * Use the session picker\n* Run parallel Claude Code sessions with Git worktrees\n* Use Claude as a unix-style utility\n  * Add Claude to your verification process\n  * Pipe in, pipe out\n  * Control output format\n* Ask Claude about its capabilities\n  * Example questions\n* Next steps\n\n### [best-practices](https://code.claude.com/docs/en/best-practices.md)\n\n* Give Claude a way to verify its work\n* Explore first, then plan, then code\n* Provide specific context in your prompts\n  * Provide rich content\n* Configure your environment\n  * Write an effective CLAUDE.md\n  * Configure permissions\n  * Use CLI tools\n  * Connect MCP servers\n  * Set up hooks\n  * Create skills\n  * Create custom subagents\n  * Install plugins\n* Communicate effectively\n  * Ask codebase questions\n  * Let Claude interview you\n* Manage your session\n  * Course-correct early and often\n  * Manage context aggressively\n  * Use subagents for investigation\n  * Rewind with checkpoints\n  * Resume conversations\n* Automate and scale\n  * Run headless mode\n  * Run multiple Claude sessions\n  * Fan out across files\n  * Safe Autonomous Mode\n* Avoid common failure patterns\n* Develop your intuition\n* Related resources\n\n## Platforms and integrations\n\n### [claude-code-on-the-web](https://code.claude.com/docs/en/claude-code-on-the-web.md)\n\n* What is Claude Code on the web?\n* Who can use Claude Code on the web?\n* Getting started\n* How it works\n* Review changes with diff view\n* Moving tasks between web and terminal\n  * From terminal to web\n    * Tips for background tasks\n  * From web to terminal\n    * Requirements for teleporting\n  * Sharing sessions\n    * Sharing from an Enterprise or Teams account\n    * Sharing from a Max or Pro account\n* Cloud environment\n  * Default image\n    * Checking available tools\n    * Language-specific setups\n    * Databases\n  * Environment configuration\n  * Dependency management\n    * Persist environment variables\n    * Dependency management limitations\n* Network access and security\n  * Network policy\n    * GitHub proxy\n    * Security proxy\n  * Access levels\n  * Default allowed domains\n    * Anthropic Services\n    * Version Control\n    * Container Registries\n    * Cloud Platforms\n    * Package Managers - JavaScript/Node\n    * Package Managers - Python\n    * Package Managers - Ruby\n    * Package Managers - Rust\n    * Package Managers - Go\n    * Package Managers - JVM\n    * Package Managers - Other Languages\n    * Linux Distributions\n    * Development Tools & Platforms\n    * Cloud Services & Monitoring\n    * Content Delivery & Mirrors\n    * Schema & Configuration\n    * Model Context Protocol\n  * Security best practices for customized network access\n* Security and isolation\n* Pricing and rate limits\n* Limitations\n* Best practices\n* Related resources\n\n### [desktop](https://code.claude.com/docs/en/desktop.md)\n\n* Installation and setup\n* Getting started\n* What you can do\n  * Choose a permission mode\n  * Work in parallel with sessions\n  * Run long-running tasks remotely\n  * Review changes with diff view\n* Extend Claude Code\n  * Connect external tools\n  * Create custom skills\n  * Automate workflows with hooks\n* Environment configuration\n* How Desktop relates to CLI\n  * CLI flag equivalents\n  * Shared configuration\n  * What's different\n* Troubleshooting\n  * Check your version\n  * \"Branch doesn't exist yet\" when opening in CLI\n  * \"Failed to load session\" error\n  * App won't quit\n  * Windows installation issues\n  * Session not finding installed tools\n  * MCP servers not working (Windows)\n  * Git LFS errors\n* Enterprise configuration\n* Related resources\n\n### [chrome](https://code.claude.com/docs/en/chrome.md)\n\n* Capabilities\n* Prerequisites\n* Get started in the CLI\n  * Enable Chrome by default\n  * Manage site permissions\n* Example workflows\n  * Test a local web application\n  * Debug with console logs\n  * Automate form filling\n  * Draft content in Google Docs\n  * Extract data from web pages\n  * Run multi-site workflows\n  * Record a demo GIF\n* Troubleshooting\n  * Extension not detected\n  * Browser not responding\n  * Connection drops during long sessions\n  * Windows-specific issues\n  * Common error messages\n* See also\n\n### [vs-code](https://code.claude.com/docs/en/vs-code.md)\n\n* Prerequisites\n* Install the extension\n* Get started\n* Use the prompt box\n  * Reference files and folders\n  * Resume past conversations\n  * Resume remote sessions from Claude.ai\n* Customize your workflow\n  * Choose where Claude lives\n  * Run multiple conversations\n  * Switch to terminal mode\n* Manage plugins\n  * Install plugins\n  * Manage marketplaces\n* Automate browser tasks with Chrome\n* VS Code commands and shortcuts\n* Configure settings\n  * Extension settings\n* VS Code extension vs. Claude Code CLI\n  * Rewind with checkpoints\n  * Run CLI in VS Code\n  * Switch between extension and CLI\n  * Include terminal output in prompts\n  * Monitor background processes\n  * Connect to external tools with MCP\n* Work with git\n  * Create commits and pull requests\n  * Use git worktrees for parallel tasks\n* Use third-party providers\n* Security and privacy\n* Fix common issues\n  * Extension won't install\n  * Spark icon not visible\n  * Claude Code never responds\n* Uninstall the extension\n* Next steps\n\n### [jetbrains](https://code.claude.com/docs/en/jetbrains.md)\n\n* Supported IDEs\n* Features\n* Installation\n  * Marketplace Installation\n* Usage\n  * From Your IDE\n  * From External Terminals\n* Configuration\n  * Claude Code Settings\n  * Plugin Settings\n    * General Settings\n    * ESC Key Configuration\n* Special Configurations\n  * Remote Development\n  * WSL Configuration\n* Troubleshooting\n  * Plugin Not Working\n  * IDE Not Detected\n  * Command Not Found\n* Security Considerations\n\n### [github-actions](https://code.claude.com/docs/en/github-actions.md)\n\n* Why use Claude Code GitHub Actions?\n* What can Claude do?\n  * Claude Code Action\n* Setup\n* Quick setup\n* Manual setup\n* Upgrading from Beta\n  * Essential changes\n  * Breaking Changes Reference\n  * Before and After Example\n* Example use cases\n  * Basic workflow\n  * Using skills\n  * Custom automation with prompts\n  * Common use cases\n* Best practices\n  * CLAUDE.md configuration\n  * Security considerations\n  * Optimizing performance\n  * CI costs\n* Configuration examples\n* Using with AWS Bedrock & Google Vertex AI\n  * Prerequisites\n    * For Google Cloud Vertex AI:\n    * For AWS Bedrock:\n* Troubleshooting\n  * Claude not responding to @claude commands\n  * CI not running on Claude's commits\n  * Authentication errors\n* Advanced configuration\n  * Action parameters\n    * Pass CLI arguments\n  * Alternative integration methods\n  * Customizing Claude's behavior\n\n### [gitlab-ci-cd](https://code.claude.com/docs/en/gitlab-ci-cd.md)\n\n* Why use Claude Code with GitLab?\n* How it works\n* What can Claude do?\n* Setup\n  * Quick setup\n  * Manual setup (recommended for production)\n* Example use cases\n  * Turn issues into MRs\n  * Get implementation help\n  * Fix bugs quickly\n* Using with AWS Bedrock & Google Vertex AI\n* Configuration examples\n  * Basic .gitlab-ci.yml (Claude API)\n  * AWS Bedrock job example (OIDC)\n  * Google Vertex AI job example (Workload Identity Federation)\n* Best practices\n  * CLAUDE.md configuration\n  * Security considerations\n  * Optimizing performance\n  * CI costs\n* Security and governance\n* Troubleshooting\n  * Claude not responding to @claude commands\n  * Job can't write comments or open MRs\n  * Authentication errors\n* Advanced configuration\n  * Common parameters and variables\n  * Customizing Claude's behavior\n\n### [slack](https://code.claude.com/docs/en/slack.md)\n\n* Use cases\n* Prerequisites\n* Setting up Claude Code in Slack\n* How it works\n  * Automatic detection\n  * Context gathering\n  * Session flow\n* User interface elements\n  * App Home\n  * Message actions\n  * Repository selection\n* Access and permissions\n  * User-level access\n  * Workspace-level access\n  * Channel-based access control\n* What's accessible where\n* Best practices\n  * Writing effective requests\n  * When to use Slack vs. web\n* Troubleshooting\n  * Sessions not starting\n  * Repository not showing\n  * Wrong repository selected\n  * Authentication errors\n  * Session expiration\n* Current limitations\n* Related resources\n\n## Build with Claude Code\n\n### [sub-agents](https://code.claude.com/docs/en/sub-agents.md)\n\n* Built-in subagents\n* Quickstart: create your first subagent\n* Configure subagents\n  * Use the /agents command\n  * Choose the subagent scope\n  * Write subagent files\n    * Supported frontmatter fields\n  * Choose a model\n  * Control subagent capabilities\n    * Available tools\n    * Restrict which subagents can be spawned\n    * Permission modes\n    * Preload skills into subagents\n    * Enable persistent memory\n      * Persistent memory tips\n    * Conditional rules with hooks\n    * Disable specific subagents\n  * Define hooks for subagents\n    * Hooks in subagent frontmatter\n    * Project-level hooks for subagent events\n* Work with subagents\n  * Understand automatic delegation\n  * Run subagents in foreground or background\n  * Common patterns\n    * Isolate high-volume operations\n    * Run parallel research\n    * Chain subagents\n  * Choose between subagents and main conversation\n  * Manage subagent context\n    * Resume subagents\n    * Auto-compaction\n* Example subagents\n  * Code reviewer\n  * Debugger\n  * Data scientist\n  * Database query validator\n* Next steps\n\n### [agent-teams](https://code.claude.com/docs/en/agent-teams.md)\n\n* When to use agent teams\n  * Compare with subagents\n* Enable agent teams\n* Start your first agent team\n* Control your agent team\n  * Choose a display mode\n  * Specify teammates and models\n  * Require plan approval for teammates\n  * Use delegate mode\n  * Talk to teammates directly\n  * Assign and claim tasks\n  * Shut down teammates\n  * Clean up the team\n  * Enforce quality gates with hooks\n* How agent teams work\n  * How Claude starts agent teams\n  * Architecture\n  * Permissions\n  * Context and communication\n  * Token usage\n* Use case examples\n  * Run a parallel code review\n  * Investigate with competing hypotheses\n* Best practices\n  * Give teammates enough context\n  * Size tasks appropriately\n  * Wait for teammates to finish\n  * Start with research and review\n  * Avoid file conflicts\n  * Monitor and steer\n* Troubleshooting\n  * Teammates not appearing\n  * Too many permission prompts\n  * Teammates stopping on errors\n  * Lead shuts down before work is done\n  * Orphaned tmux sessions\n* Limitations\n* Next steps\n\n### [plugins](https://code.claude.com/docs/en/plugins.md)\n\n* When to use plugins vs standalone configuration\n* Quickstart\n  * Prerequisites\n  * Create your first plugin\n* Hello Command\n  * Plugin structure overview\n  * Develop more complex plugins\n    * Add Skills to your plugin\n    * Add LSP servers to your plugin\n    * Organize complex plugins\n    * Test your plugins locally\n    * Debug plugin issues\n    * Share your plugins\n  * Convert existing configurations to plugins\n    * Migration steps\n    * What changes when migrating\n  * Next steps\n    * For plugin users\n    * For plugin developers\n\n### [discover-plugins](https://code.claude.com/docs/en/discover-plugins.md)\n\n* How marketplaces work\n* Official Anthropic marketplace\n  * Code intelligence\n    * What Claude gains from code intelligence plugins\n  * External integrations\n  * Development workflows\n  * Output styles\n* Try it: add the demo marketplace\n* Add marketplaces\n  * Add from GitHub\n  * Add from other Git hosts\n  * Add from local paths\n  * Add from remote URLs\n* Install plugins\n* Manage installed plugins\n* Manage marketplaces\n  * Use the interactive interface\n  * Use CLI commands\n  * Configure auto-updates\n* Configure team marketplaces\n* Troubleshooting\n  * /plugin command not recognized\n  * Common issues\n  * Code intelligence issues\n* Next steps\n\n### [skills](https://code.claude.com/docs/en/skills.md)\n\n* Getting started\n  * Create your first skill\n  * Where skills live\n    * Automatic discovery from nested directories\n    * Skills from additional directories\n* Configure skills\n  * Types of skill content\n  * Frontmatter reference\n    * Available string substitutions\n  * Add supporting files\n  * Control who invokes a skill\n  * Restrict tool access\n  * Pass arguments to skills\n* Advanced patterns\n  * Inject dynamic context\n  * Run skills in a subagent\n    * Example: Research skill using Explore agent\n  * Restrict Claude's skill access\n* Share skills\n  * Generate visual output\n* Troubleshooting\n  * Skill not triggering\n  * Skill triggers too often\n  * Claude doesn't see all my skills\n* Related resources\n\n### [output-styles](https://code.claude.com/docs/en/output-styles.md)\n\n* Built-in output styles\n* How output styles work\n* Change your output style\n* Create a custom output style\n  * Frontmatter\n* Comparisons to related features\n  * Output Styles vs. CLAUDE.md vs. --append-system-prompt\n  * Output Styles vs. [Agents](/en/sub-agents)\n  * Output Styles vs. [Skills](/en/skills)\n\n### [hooks-guide](https://code.claude.com/docs/en/hooks-guide.md)\n\n* Set up your first hook\n* What you can automate\n  * Get notified when Claude needs input\n  * Auto-format code after edits\n  * Block edits to protected files\n  * Re-inject context after compaction\n* How hooks work\n  * Read input and return output\n    * Hook input\n    * Hook output\n    * Structured JSON output\n  * Filter hooks with matchers\n  * Configure hook location\n* Prompt-based hooks\n* Agent-based hooks\n* Limitations and troubleshooting\n  * Limitations\n  * Hook not firing\n  * Hook error in output\n  * `/hooks` shows no hooks configured\n  * Stop hook runs forever\n  * JSON validation failed\n  * Debug techniques\n* Learn more\n\n### [headless](https://code.claude.com/docs/en/headless.md)\n\n* Basic usage\n* Examples\n  * Get structured output\n  * Stream responses\n  * Auto-approve tools\n  * Create a commit\n  * Customize the system prompt\n  * Continue conversations\n* Next steps\n\n### [mcp](https://code.claude.com/docs/en/mcp.md)\n\n* What you can do with MCP\n* Popular MCP servers\n* Installing MCP servers\n  * Option 1: Add a remote HTTP server\n  * Option 2: Add a remote SSE server\n  * Option 3: Add a local stdio server\n  * Managing your servers\n  * Dynamic tool updates\n  * Plugin-provided MCP servers\n* MCP installation scopes\n  * Local scope\n  * Project scope\n  * User scope\n  * Choosing the right scope\n  * Scope hierarchy and precedence\n  * Environment variable expansion in `.mcp.json`\n* Practical examples\n  * Example: Monitor errors with Sentry\n  * Example: Connect to GitHub for code reviews\n  * Example: Query your PostgreSQL database\n* Authenticate with remote MCP servers\n  * Use pre-configured OAuth credentials\n* Add MCP servers from JSON configuration\n* Import MCP servers from Claude Desktop\n* Use Claude Code as an MCP server\n* MCP output limits and warnings\n* Use MCP resources\n  * Reference MCP resources\n* Scale with MCP Tool Search\n  * How it works\n  * For MCP server authors\n  * Configure tool search\n* Use MCP prompts as commands\n  * Execute MCP prompts\n* Managed MCP configuration\n  * Option 1: Exclusive control with managed-mcp.json\n  * Option 2: Policy-based control with allowlists and denylists\n    * Restriction options\n    * Example configuration\n    * How command-based restrictions work\n    * How URL-based restrictions work\n    * Allowlist behavior (`allowedMcpServers`)\n    * Denylist behavior (`deniedMcpServers`)\n    * Important notes\n\n### [troubleshooting](https://code.claude.com/docs/en/troubleshooting.md)\n\n* Common installation issues\n  * Windows installation issues: errors in WSL\n  * WSL2 sandbox setup\n  * Linux and Mac installation issues: permission or command not found errors\n    * Recommended solution: Native Claude Code installation\n  * Windows: \"Claude Code on Windows requires git-bash\"\n  * Windows: \"installMethod is native, but claude command not found\"\n* Permissions and authentication\n  * Repeated permission prompts\n  * Authentication issues\n* Configuration file locations\n  * Resetting configuration\n* Performance and stability\n  * High CPU or memory usage\n  * Command hangs or freezes\n  * Search and discovery issues\n  * Slow or incomplete search results on WSL\n* IDE integration issues\n  * JetBrains IDE not detected on WSL2\n    * WSL2 networking modes\n  * Reporting Windows IDE integration issues (both native and WSL)\n  * Escape key not working in JetBrains (IntelliJ, PyCharm, etc.) terminals\n* Markdown formatting issues\n  * Missing language tags in code blocks\n  * Inconsistent spacing and formatting\n  * Best practices for markdown generation\n* Getting more help\n\n## Deployment\n\n### [third-party-integrations](https://code.claude.com/docs/en/third-party-integrations.md)\n\n* Compare deployment options\n* Configure proxies and gateways\n  * Amazon Bedrock\n  * Microsoft Foundry\n  * Google Vertex AI\n* Best practices for organizations\n  * Invest in documentation and memory\n  * Simplify deployment\n  * Start with guided usage\n  * Configure security policies\n  * Leverage MCP for integrations\n* Next steps\n\n### [amazon-bedrock](https://code.claude.com/docs/en/amazon-bedrock.md)\n\n* Prerequisites\n* Setup\n  * 1. Submit use case details\n  * 2. Configure AWS credentials\n    * Advanced credential configuration\n      * Example configuration\n      * Configuration settings explained\n  * 3. Configure Claude Code\n  * 4. Model configuration\n* IAM configuration\n* AWS Guardrails\n* Troubleshooting\n* Additional resources\n\n### [google-vertex-ai](https://code.claude.com/docs/en/google-vertex-ai.md)\n\n* Prerequisites\n* Region Configuration\n* Setup\n  * 1. Enable Vertex AI API\n  * 2. Request model access\n  * 3. Configure GCP credentials\n  * 4. Configure Claude Code\n  * 5. Model configuration\n* IAM configuration\n* 1M token context window\n* Troubleshooting\n* Additional resources\n\n### [microsoft-foundry](https://code.claude.com/docs/en/microsoft-foundry.md)\n\n* Prerequisites\n* Setup\n  * 1. Provision Microsoft Foundry resource\n  * 2. Configure Azure credentials\n  * 3. Configure Claude Code\n* Azure RBAC configuration\n* Troubleshooting\n* Additional resources\n\n### [network-config](https://code.claude.com/docs/en/network-config.md)\n\n* Proxy configuration\n  * Environment variables\n  * Basic authentication\n* Custom CA certificates\n* mTLS authentication\n* Network access requirements\n* Additional resources\n\n### [llm-gateway](https://code.claude.com/docs/en/llm-gateway.md)\n\n* Gateway requirements\n* Configuration\n  * Model selection\n* LiteLLM configuration\n  * Prerequisites\n  * Basic LiteLLM setup\n    * Authentication methods\n      * Static API key\n      * Dynamic API key with helper\n    * Unified endpoint (recommended)\n    * Provider-specific pass-through endpoints (alternative)\n      * Claude API through LiteLLM\n      * Amazon Bedrock through LiteLLM\n      * Google Vertex AI through LiteLLM\n* Additional resources\n\n### [devcontainer](https://code.claude.com/docs/en/devcontainer.md)\n\n* Key features\n* Getting started in 4 steps\n* Configuration breakdown\n* Security features\n* Customization options\n* Example use cases\n  * Secure client work\n  * Team onboarding\n  * Consistent CI/CD environments\n* Related resources\n\n## Administration\n\n### [setup](https://code.claude.com/docs/en/setup.md)\n\n* System requirements\n  * Additional dependencies\n* Installation\n  * Platform-specific setup\n  * Authentication\n    * For individuals\n    * For teams and organizations\n  * Install a specific version\n  * Binary integrity and code signing\n* NPM installation (deprecated)\n* Windows setup\n* Update Claude Code\n  * Auto updates\n  * Configure release channel\n  * Disable auto-updates\n  * Update manually\n* Uninstall Claude Code\n  * Native installation\n  * Homebrew installation\n  * WinGet installation\n  * NPM installation\n  * Clean up configuration files (optional)\n\n### [authentication](https://code.claude.com/docs/en/authentication.md)\n\n* Authentication methods\n  * Claude for Teams or Enterprise\n  * Claude Console authentication\n  * Cloud provider authentication\n* Credential management\n* See also\n\n### [security](https://code.claude.com/docs/en/security.md)\n\n* How we approach security\n  * Security foundation\n  * Permission-based architecture\n  * Built-in protections\n  * User responsibility\n* Protect against prompt injection\n  * Core protections\n  * Privacy safeguards\n  * Additional safeguards\n* MCP security\n* IDE security\n* Cloud execution security\n* Security best practices\n  * Working with sensitive code\n  * Team security\n  * Reporting security issues\n* Related resources\n\n### [server-managed-settings](https://code.claude.com/docs/en/server-managed-settings.md)\n\n* Requirements\n* Choose between server-managed and endpoint-managed settings\n* Configure server-managed settings\n  * Verify settings delivery\n  * Access control\n  * Current limitations\n* Settings delivery\n  * Settings precedence\n  * Fetch and caching behavior\n  * Security approval dialogs\n* Platform availability\n* Audit logging\n* Security considerations\n* See also\n\n### [data-usage](https://code.claude.com/docs/en/data-usage.md)\n\n* Data policies\n  * Data training policy\n  * Development Partner Program\n  * Feedback using the `/bug` command\n  * Session quality surveys\n  * Data retention\n* Data access\n* Local Claude Code: Data flow and dependencies\n  * Cloud execution: Data flow and dependencies\n* Telemetry services\n* Default behaviors by API provider\n\n### [monitoring-usage](https://code.claude.com/docs/en/monitoring-usage.md)\n\n* Quick start\n* Administrator configuration\n* Configuration details\n  * Common configuration variables\n  * Metrics cardinality control\n  * Dynamic headers\n    * Settings configuration\n    * Script requirements\n    * Refresh behavior\n  * Multi-team organization support\n  * Example configurations\n* Available metrics and events\n  * Standard attributes\n  * Metrics\n  * Metric details\n    * Session counter\n    * Lines of code counter\n    * Pull request counter\n    * Commit counter\n    * Cost counter\n    * Token counter\n    * Code edit tool decision counter\n    * Active time counter\n  * Events\n    * User prompt event\n    * Tool result event\n    * API request event\n    * API error event\n    * Tool decision event\n* Interpreting metrics and events data\n  * Usage monitoring\n  * Cost monitoring\n  * Alerting and segmentation\n  * Event analysis\n* Backend considerations\n  * For metrics\n  * For events/logs\n* Service information\n* ROI measurement resources\n* Security/privacy considerations\n* Monitoring Claude Code on Amazon Bedrock\n\n### [costs](https://code.claude.com/docs/en/costs.md)\n\n* Track your costs\n  * Using the `/cost` command\n* Managing costs for teams\n  * Rate limit recommendations\n  * Agent team token costs\n* Reduce token usage\n  * Manage context proactively\n  * Choose the right model\n  * Reduce MCP server overhead\n  * Install code intelligence plugins for typed languages\n  * Offload processing to hooks and skills\n  * Move instructions from CLAUDE.md to skills\n  * Adjust extended thinking\n  * Delegate verbose operations to subagents\n  * Manage agent team costs\n  * Write specific prompts\n  * Work efficiently on complex tasks\n* Background token usage\n* Understanding changes in Claude Code behavior\n\n### [analytics](https://code.claude.com/docs/en/analytics.md)\n\n* Access analytics for Teams and Enterprise\n  * Enable contribution metrics\n  * Review summary metrics\n  * Explore the charts\n    * Track adoption\n    * Measure PRs per user\n    * View pull requests breakdown\n    * Find top contributors\n  * PR attribution\n    * Tagging criteria\n    * Attribution process\n    * Time window\n    * Excluded files\n    * Attribution notes\n  * Get the most from analytics\n    * Monitor adoption\n    * Measure ROI\n    * Identify power users\n    * Access data programmatically\n* Access analytics for API customers\n  * View team insights\n* Related resources\n\n### [plugin-marketplaces](https://code.claude.com/docs/en/plugin-marketplaces.md)\n\n* Overview\n* Walkthrough: create a local marketplace\n* Create the marketplace file\n* Marketplace schema\n  * Required fields\n  * Owner fields\n  * Optional metadata\n* Plugin entries\n  * Required fields\n  * Optional plugin fields\n* Plugin sources\n  * Relative paths\n  * GitHub repositories\n  * Git repositories\n  * Advanced plugin entries\n* Host and distribute marketplaces\n  * Host on GitHub (recommended)\n  * Host on other git services\n  * Private repositories\n  * Test locally before distribution\n  * Require marketplaces for your team\n  * Managed marketplace restrictions\n    * Common configurations\n    * How restrictions work\n* Validation and testing\n* Troubleshooting\n  * Marketplace not loading\n  * Marketplace validation errors\n  * Plugin installation failures\n  * Private repository authentication fails\n  * Plugins with relative paths fail in URL-based marketplaces\n  * Files not found after installation\n* See also\n\n## Configuration\n\n### [settings](https://code.claude.com/docs/en/settings.md)\n\n* Configuration scopes\n  * Available scopes\n  * When to use each scope\n  * How scopes interact\n  * What uses scopes\n* Settings files\n  * Available settings\n  * Permission settings\n  * Permission rule syntax\n  * Sandbox settings\n  * Attribution settings\n  * File suggestion settings\n  * Hook configuration\n  * Settings precedence\n  * Key points about the configuration system\n  * System prompt\n  * Excluding sensitive files\n* Subagent configuration\n* Plugin configuration\n  * Plugin settings\n    * `enabledPlugins`\n    * `extraKnownMarketplaces`\n    * `strictKnownMarketplaces`\n  * Managing plugins\n* Environment variables\n* Tools available to Claude\n  * Bash tool behavior\n  * Extending tools with hooks\n* See also\n\n### [permissions](https://code.claude.com/docs/en/permissions.md)\n\n* Permission system\n* Manage permissions\n* Permission modes\n* Permission rule syntax\n  * Match all uses of a tool\n  * Use specifiers for fine-grained control\n  * Wildcard patterns\n* Tool-specific permission rules\n  * Bash\n  * Read and Edit\n  * WebFetch\n  * MCP\n  * Task (subagents)\n* Extend permissions with hooks\n* Working directories\n* How permissions interact with sandboxing\n* Managed settings\n  * Managed-only settings\n* Settings precedence\n* Example configurations\n* See also\n\n### [sandboxing](https://code.claude.com/docs/en/sandboxing.md)\n\n* Overview\n* Why sandboxing matters\n* How it works\n  * Filesystem isolation\n  * Network isolation\n  * OS-level enforcement\n* Getting started\n  * Prerequisites\n  * Enable sandboxing\n  * Sandbox modes\n  * Configure sandboxing\n* Security benefits\n  * Protection against prompt injection\n  * Reduced attack surface\n  * Transparent operation\n* Security Limitations\n* How sandboxing relates to permissions\n* Advanced usage\n  * Custom proxy configuration\n  * Integration with existing security tools\n* Best practices\n* Open source\n* Limitations\n* See also\n\n### [terminal-config](https://code.claude.com/docs/en/terminal-config.md)\n\n* Themes and appearance\n* Line breaks\n* Notification setup\n  * iTerm 2 system notifications\n  * Custom notification hooks\n* Handling large inputs\n* Vim Mode\n\n### [model-config](https://code.claude.com/docs/en/model-config.md)\n\n* Available models\n  * Model aliases\n  * Setting your model\n* Special model behavior\n  * `default` model setting\n  * `opusplan` model setting\n  * Adjust effort level\n  * Extended context with \\[1m]\n* Checking your current model\n* Environment variables\n  * Prompt caching configuration\n\n### [fast-mode](https://code.claude.com/docs/en/fast-mode.md)\n\n* Toggle fast mode\n* Understand the cost tradeoff\n* Decide when to use fast mode\n  * Fast mode vs effort level\n* Requirements\n  * Enable fast mode for your organization\n* Handle rate limits\n* Research preview\n* See also\n\n### [memory](https://code.claude.com/docs/en/memory.md)\n\n* Determine memory type\n* Auto memory\n  * What Claude remembers\n  * Where auto memory is stored\n  * How it works\n  * Manage auto memory\n* CLAUDE.md imports\n* How Claude looks up memories\n  * Load memory from additional directories\n* Directly edit memories with `/memory`\n* Set up project memory\n* Modular rules with `.claude/rules/`\n  * Basic structure\n  * Path-specific rules\n  * Glob patterns\n  * Subdirectories\n  * Symlinks\n  * User-level rules\n* Organization-level memory management\n* Memory best practices\n\n### [statusline](https://code.claude.com/docs/en/statusline.md)\n\n* Set up a status line\n  * Use the /statusline command\n  * Manually configure a status line\n  * Disable the status line\n* Build a status line step by step\n* How status lines work\n* Available data\n  * Context window fields\n* Examples\n  * Context window usage\n  * Git status with colors\n  * Cost and duration tracking\n  * Display multiple lines\n  * Clickable links\n  * Cache expensive operations\n* Tips\n* Troubleshooting\n\n### [keybindings](https://code.claude.com/docs/en/keybindings.md)\n\n* Configuration file\n* Contexts\n* Available actions\n  * App actions\n  * History actions\n  * Chat actions\n  * Autocomplete actions\n  * Confirmation actions\n  * Permission actions\n  * Transcript actions\n  * History search actions\n  * Task actions\n  * Theme actions\n  * Help actions\n  * Tabs actions\n  * Attachments actions\n  * Footer actions\n  * Message selector actions\n  * Diff actions\n  * Model picker actions\n  * Select actions\n  * Plugin actions\n  * Settings actions\n* Keystroke syntax\n  * Modifiers\n  * Uppercase letters\n  * Chords\n  * Special keys\n* Unbind default shortcuts\n* Reserved shortcuts\n* Terminal conflicts\n* Vim mode interaction\n* Validation\n\n## Reference\n\n### [cli-reference](https://code.claude.com/docs/en/cli-reference.md)\n\n* CLI commands\n* CLI flags\n  * Agents flag format\n  * System prompt flags\n* See also\n\n### [interactive-mode](https://code.claude.com/docs/en/interactive-mode.md)\n\n* Keyboard shortcuts\n  * General controls\n  * Text editing\n  * Theme and display\n  * Multiline input\n  * Quick commands\n* Built-in commands\n  * MCP prompts\n* Vim editor mode\n  * Mode switching\n  * Navigation (NORMAL mode)\n  * Editing (NORMAL mode)\n  * Text objects (NORMAL mode)\n* Command history\n  * Reverse search with Ctrl+R\n* Background bash commands\n  * How backgrounding works\n  * Bash mode with `!` prefix\n* Prompt suggestions\n* Task list\n* PR review status\n* See also\n\n### [checkpointing](https://code.claude.com/docs/en/checkpointing.md)\n\n* How checkpoints work\n  * Automatic tracking\n  * Rewind and summarize\n    * Restore vs. summarize\n* Common use cases\n* Limitations\n  * Bash command changes not tracked\n  * External changes not tracked\n  * Not a replacement for version control\n* See also\n\n### [hooks](https://code.claude.com/docs/en/hooks.md)\n\n* Hook lifecycle\n  * How a hook resolves\n* Configuration\n  * Hook locations\n  * Matcher patterns\n    * Match MCP tools\n  * Hook handler fields\n    * Common fields\n    * Command hook fields\n    * Prompt and agent hook fields\n  * Reference scripts by path\n  * Hooks in skills and agents\n  * The `/hooks` menu\n  * Disable or remove hooks\n* Hook input and output\n  * Common input fields\n  * Exit code output\n    * Exit code 2 behavior per event\n  * JSON output\n    * Decision control\n* Hook events\n  * SessionStart\n    * SessionStart input\n    * SessionStart decision control\n    * Persist environment variables\n  * UserPromptSubmit\n    * UserPromptSubmit input\n    * UserPromptSubmit decision control\n  * PreToolUse\n    * PreToolUse input\n      * Bash\n      * Write\n      * Edit\n      * Read\n      * Glob\n      * Grep\n      * WebFetch\n      * WebSearch\n      * Task\n    * PreToolUse decision control\n  * PermissionRequest\n    * PermissionRequest input\n    * PermissionRequest decision control\n  * PostToolUse\n    * PostToolUse input\n    * PostToolUse decision control\n  * PostToolUseFailure\n    * PostToolUseFailure input\n    * PostToolUseFailure decision control\n  * Notification\n    * Notification input\n  * SubagentStart\n    * SubagentStart input\n  * SubagentStop\n    * SubagentStop input\n  * Stop\n    * Stop input\n    * Stop decision control\n  * TeammateIdle\n    * TeammateIdle input\n    * TeammateIdle decision control\n  * TaskCompleted\n    * TaskCompleted input\n    * TaskCompleted decision control\n  * PreCompact\n    * PreCompact input\n  * SessionEnd\n    * SessionEnd input\n* Prompt-based hooks\n  * How prompt-based hooks work\n  * Prompt hook configuration\n  * Response schema\n  * Example: Multi-criteria Stop hook\n* Agent-based hooks\n  * How agent hooks work\n  * Agent hook configuration\n* Run hooks in the background\n  * Configure an async hook\n  * How async hooks execute\n  * Example: run tests after file changes\n  * Limitations\n* Security considerations\n  * Disclaimer\n  * Security best practices\n* Debug hooks\n\n### [plugins-reference](https://code.claude.com/docs/en/plugins-reference.md)\n\n* Plugin components reference\n  * Skills\n  * Agents\n  * Hooks\n  * MCP servers\n  * LSP servers\n* Plugin installation scopes\n* Plugin manifest schema\n  * Complete schema\n  * Required fields\n  * Metadata fields\n  * Component path fields\n  * Path behavior rules\n  * Environment variables\n* Plugin caching and file resolution\n  * How plugin caching works\n  * Path traversal limitations\n  * Working with external dependencies\n* Plugin directory structure\n  * Standard plugin layout\n  * File locations reference\n* CLI commands reference\n  * plugin install\n  * plugin uninstall\n  * plugin enable\n  * plugin disable\n  * plugin update\n* Debugging and development tools\n  * Debugging commands\n  * Common issues\n  * Example error messages\n  * Hook troubleshooting\n  * MCP server troubleshooting\n  * Directory structure mistakes\n* Distribution and versioning reference\n  * Version management\n* See also\n\n## Resources\n\n### [legal-and-compliance](https://code.claude.com/docs/en/legal-and-compliance.md)\n\n* Legal agreements\n  * License\n  * Commercial agreements\n* Compliance\n  * Healthcare compliance (BAA)\n* Security and trust\n  * Trust and safety\n  * Security vulnerability reporting\n"}]},"uuid":"7fd21f59-3013-44e1-b87a-07fac46c2c6b","timestamp":"2026-02-16T21:52:55.706Z","sourceToolAssistantUUID":"c3d8e163-b9db-43c5-a2c8-12047544a30e"}
{"parentUuid":"7fd21f59-3013-44e1-b87a-07fac46c2c6b","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me fetch the specific documentation pages about headless mode, autonomous agents, and related topics."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"94d47707-a184-4b4c-90f0-4eb32c55801c","timestamp":"2026-02-16T21:52:57.424Z"}
{"parentUuid":"94d47707-a184-4b4c-90f0-4eb32c55801c","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014f8TJnP9jqbw1Pn7cE9jJJ","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/headless.md","prompt":"headless mode, background execution, autonomous agents"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"dba68b74-9033-4a56-ace7-88a6942fa44e","timestamp":"2026-02-16T21:52:57.852Z"}
{"parentUuid":"dba68b74-9033-4a56-ace7-88a6942fa44e","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JT6y3pdBtZSv8t3YBUSYGu","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/best-practices.md","prompt":"autonomous mode, background execution, safe autonomous mode, running headless, minimal human intervention"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"0f5bd84f-028d-4c47-9b94-b1dd52a3fe02","timestamp":"2026-02-16T21:52:58.379Z"}
{"parentUuid":"0f5bd84f-028d-4c47-9b94-b1dd52a3fe02","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A8YPoeZSHX9XXt4fr8CAGJ","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/sub-agents.md","prompt":"subagents, background execution, autonomous agents, foreground background"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"dabc32e5-ceee-4441-85bf-4878799bf9a4","timestamp":"2026-02-16T21:52:58.776Z"}
{"parentUuid":"dabc32e5-ceee-4441-85bf-4878799bf9a4","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HhPLbJmewb619qVCi5fAo6","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/agent-teams.md","prompt":"agent teams, parallel agents, autonomous execution, multiple agents"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"dfec715e-486a-4e31-b737-9bde5792e3b3","timestamp":"2026-02-16T21:52:59.197Z"}
{"parentUuid":"dfec715e-486a-4e31-b737-9bde5792e3b3","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017nLXyuCUUc6qC85x2n5RnE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FB7eV9jBeZ9qPNJebPdYRH","name":"WebFetch","input":{"url":"https://code.claude.com/docs/en/hooks-guide.md","prompt":"hooks, monitoring, autonomous agents, background execution, controlling agents"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":9904,"cache_read_input_tokens":12533,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9904},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPArq5QDSw3v8WYwey","type":"assistant","uuid":"a57dfa49-e415-4378-b27e-e4c4908aa1db","timestamp":"2026-02-16T21:52:59.544Z"}
{"parentUuid":"dba68b74-9033-4a56-ace7-88a6942fa44e","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014f8TJnP9jqbw1Pn7cE9jJJ","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# Run Claude Code programmatically\n\n> Use the Agent SDK to run Claude Code programmatically from the CLI, Python, or TypeScript.\n\nThe [Agent SDK](https://platform.claude.com/docs/en/agent-sdk/overview) gives you the same tools, agent loop, and context management that power Claude Code. It's available as a CLI for scripts and CI/CD, or as [Python](https://platform.claude.com/docs/en/agent-sdk/python) and [TypeScript](https://platform.claude.com/docs/en/agent-sdk/typescript) packages for full programmatic control.\n\n<Note>\n  The CLI was previously called \"headless mode.\" The `-p` flag and all CLI options work the same way.\n</Note>\n\nTo run Claude Code programmatically from the CLI, pass `-p` with your prompt and any [CLI options](/en/cli-reference):\n\n```bash  theme={null}\nclaude -p \"Find and fix the bug in auth.py\" --allowedTools \"Read,Edit,Bash\"\n```\n\nThis page covers using the Agent SDK via the CLI (`claude -p`). For the Python and TypeScript SDK packages with structured outputs, tool approval callbacks, and native message objects, see the [full Agent SDK documentation](https://platform.claude.com/docs/en/agent-sdk/overview).\n\n## Basic usage\n\nAdd the `-p` (or `--print`) flag to any `claude` command to run it non-interactively. All [CLI options](/en/cli-reference) work with `-p`, including:\n\n* `--continue` for [continuing conversations](#continue-conversations)\n* `--allowedTools` for [auto-approving tools](#auto-approve-tools)\n* `--output-format` for [structured output](#get-structured-output)\n\nThis example asks Claude a question about your codebase and prints the response:\n\n```bash  theme={null}\nclaude -p \"What does the auth module do?\"\n```\n\n## Examples\n\nThese examples highlight common CLI patterns.\n\n### Get structured output\n\nUse `--output-format` to control how responses are returned:\n\n* `text` (default): plain text output\n* `json`: structured JSON with result, session ID, and metadata\n* `stream-json`: newline-delimited JSON for real-time streaming\n\nThis example returns a project summary as JSON with session metadata, with the text result in the `result` field:\n\n```bash  theme={null}\nclaude -p \"Summarize this project\" --output-format json\n```\n\nTo get output conforming to a specific schema, use `--output-format json` with `--json-schema` and a [JSON Schema](https://json-schema.org/) definition. The response includes metadata about the request (session ID, usage, etc.) with the structured output in the `structured_output` field.\n\nThis example extracts function names and returns them as an array of strings:\n\n```bash  theme={null}\nclaude -p \"Extract the main function names from auth.py\" \\\n  --output-format json \\\n  --json-schema '{\"type\":\"object\",\"properties\":{\"functions\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"functions\"]}'\n```\n\n<Tip>\n  Use a tool like [jq](https://jqlang.github.io/jq/) to parse the response and extract specific fields:\n\n  ```bash  theme={null}\n  # Extract the text result\n  claude -p \"Summarize this project\" --output-format json | jq -r '.result'\n\n  # Extract structured output\n  claude -p \"Extract function names from auth.py\" \\\n    --output-format json \\\n    --json-schema '{\"type\":\"object\",\"properties\":{\"functions\":{\"type\":\"array\",\"items\":{\"type\":\"string\"}}},\"required\":[\"functions\"]}' \\\n    | jq '.structured_output'\n  ```\n</Tip>\n\n### Stream responses\n\nUse `--output-format stream-json` with `--verbose` and `--include-partial-messages` to receive tokens as they're generated. Each line is a JSON object representing an event:\n\n```bash  theme={null}\nclaude -p \"Explain recursion\" --output-format stream-json --verbose --include-partial-messages\n```\n\nThe following example uses [jq](https://jqlang.github.io/jq/) to filter for text deltas and display just the streaming text. The `-r` flag outputs raw strings (no quotes) and `-j` joins without newlines so tokens stream continuously:\n\n```bash  theme={null}\nclaude -p \"Write a poem\" --output-format stream-json --verbose --include-partial-messages | \\\n  jq -rj 'select(.type == \"stream_event\" and .event.delta.type? == \"text_delta\") | .event.delta.text'\n```\n\nFor programmatic streaming with callbacks and message objects, see [Stream responses in real-time](https://platform.claude.com/docs/en/agent-sdk/streaming-output) in the Agent SDK documentation.\n\n### Auto-approve tools\n\nUse `--allowedTools` to let Claude use certain tools without prompting. This example runs a test suite and fixes failures, allowing Claude to execute Bash commands and read/edit files without asking for permission:\n\n```bash  theme={null}\nclaude -p \"Run the test suite and fix any failures\" \\\n  --allowedTools \"Bash,Read,Edit\"\n```\n\n### Create a commit\n\nThis example reviews staged changes and creates a commit with an appropriate message:\n\n```bash  theme={null}\nclaude -p \"Look at my staged changes and create an appropriate commit\" \\\n  --allowedTools \"Bash(git diff *),Bash(git log *),Bash(git status *),Bash(git commit *)\"\n```\n\nThe `--allowedTools` flag uses [permission rule syntax](/en/settings#permission-rule-syntax). The trailing ` *` enables prefix matching, so `Bash(git diff *)` allows any command starting with `git diff`. The space before `*` is important: without it, `Bash(git diff*)` would also match `git diff-index`.\n\n<Note>\n  User-invoked [skills](/en/skills) like `/commit` and [built-in commands](/en/interactive-mode#built-in-commands) are only available in interactive mode. In `-p` mode, describe the task you want to accomplish instead.\n</Note>\n\n### Customize the system prompt\n\nUse `--append-system-prompt` to add instructions while keeping Claude Code's default behavior. This example pipes a PR diff to Claude and instructs it to review for security vulnerabilities:\n\n```bash  theme={null}\ngh pr diff \"$1\" | claude -p \\\n  --append-system-prompt \"You are a security engineer. Review for vulnerabilities.\" \\\n  --output-format json\n```\n\nSee [system prompt flags](/en/cli-reference#system-prompt-flags) for more options including `--system-prompt` to fully replace the default prompt.\n\n### Continue conversations\n\nUse `--continue` to continue the most recent conversation, or `--resume` with a session ID to continue a specific conversation. This example runs a review, then sends follow-up prompts:\n\n```bash  theme={null}\n# First request\nclaude -p \"Review this codebase for performance issues\"\n\n# Continue the most recent conversation\nclaude -p \"Now focus on the database queries\" --continue\nclaude -p \"Generate a summary of all issues found\" --continue\n```\n\nIf you're running multiple conversations, capture the session ID to resume a specific one:\n\n```bash  theme={null}\nsession_id=$(claude -p \"Start a review\" --output-format json | jq -r '.session_id')\nclaude -p \"Continue that review\" --resume \"$session_id\"\n```\n\n## Next steps\n\n<CardGroup cols={2}>\n  <Card title=\"Agent SDK quickstart\" icon=\"play\" href=\"https://platform.claude.com/docs/en/agent-sdk/quickstart\">\n    Build your first agent with Python or TypeScript\n  </Card>\n\n  <Card title=\"CLI reference\" icon=\"terminal\" href=\"/en/cli-reference\">\n    Explore all CLI flags and options\n  </Card>\n\n  <Card title=\"GitHub Actions\" icon=\"github\" href=\"/en/github-actions\">\n    Use the Agent SDK in GitHub workflows\n  </Card>\n\n  <Card title=\"GitLab CI/CD\" icon=\"gitlab\" href=\"/en/gitlab-ci-cd\">\n    Use the Agent SDK in GitLab pipelines\n  </Card>\n</CardGroup>\n"}]},"uuid":"e2b36beb-8d84-48ef-874b-0b49339e5a26","timestamp":"2026-02-16T21:52:59.850Z","sourceToolAssistantUUID":"dba68b74-9033-4a56-ace7-88a6942fa44e"}
{"parentUuid":"dabc32e5-ceee-4441-85bf-4878799bf9a4","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A8YPoeZSHX9XXt4fr8CAGJ","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# Create custom subagents\n\n> Create and use specialized AI subagents in Claude Code for task-specific workflows and improved context management.\n\nSubagents are specialized AI assistants that handle specific types of tasks. Each subagent runs in its own context window with a custom system prompt, specific tool access, and independent permissions. When Claude encounters a task that matches a subagent's description, it delegates to that subagent, which works independently and returns results.\n\n<Note>\n  If you need multiple agents working in parallel and communicating with each other, see [agent teams](/en/agent-teams) instead. Subagents work within a single session; agent teams coordinate across separate sessions.\n</Note>\n\nSubagents help you:\n\n* **Preserve context** by keeping exploration and implementation out of your main conversation\n* **Enforce constraints** by limiting which tools a subagent can use\n* **Reuse configurations** across projects with user-level subagents\n* **Specialize behavior** with focused system prompts for specific domains\n* **Control costs** by routing tasks to faster, cheaper models like Haiku\n\nClaude uses each subagent's description to decide when to delegate tasks. When you create a subagent, write a clear description so Claude knows when to use it.\n\nClaude Code includes several built-in subagents like **Explore**, **Plan**, and **general-purpose**. You can also create custom subagents to handle specific tasks. This page covers the [built-in subagents](#built-in-subagents), [how to create your own](#quickstart-create-your-first-subagent), [full configuration options](#configure-subagents), [patterns for working with subagents](#work-with-subagents), and [example subagents](#example-subagents).\n\n## Built-in subagents\n\nClaude Code includes built-in subagents that Claude automatically uses when appropriate. Each inherits the parent conversation's permissions with additional tool restrictions.\n\n<Tabs>\n  <Tab title=\"Explore\">\n    A fast, read-only agent optimized for searching and analyzing codebases.\n\n    * **Model**: Haiku (fast, low-latency)\n    * **Tools**: Read-only tools (denied access to Write and Edit tools)\n    * **Purpose**: File discovery, code search, codebase exploration\n\n    Claude delegates to Explore when it needs to search or understand a codebase without making changes. This keeps exploration results out of your main conversation context.\n\n    When invoking Explore, Claude specifies a thoroughness level: **quick** for targeted lookups, **medium** for balanced exploration, or **very thorough** for comprehensive analysis.\n  </Tab>\n\n  <Tab title=\"Plan\">\n    A research agent used during [plan mode](/en/common-workflows#use-plan-mode-for-safe-code-analysis) to gather context before presenting a plan.\n\n    * **Model**: Inherits from main conversation\n    * **Tools**: Read-only tools (denied access to Write and Edit tools)\n    * **Purpose**: Codebase research for planning\n\n    When you're in plan mode and Claude needs to understand your codebase, it delegates research to the Plan subagent. This prevents infinite nesting (subagents cannot spawn other subagents) while still gathering necessary context.\n  </Tab>\n\n  <Tab title=\"General-purpose\">\n    A capable agent for complex, multi-step tasks that require both exploration and action.\n\n    * **Model**: Inherits from main conversation\n    * **Tools**: All tools\n    * **Purpose**: Complex research, multi-step operations, code modifications\n\n    Claude delegates to general-purpose when the task requires both exploration and modification, complex reasoning to interpret results, or multiple dependent steps.\n  </Tab>\n\n  <Tab title=\"Other\">\n    Claude Code includes additional helper agents for specific tasks. These are typically invoked automatically, so you don't need to use them directly.\n\n    | Agent             | Model    | When Claude uses it                                      |\n    | :---------------- | :------- | :------------------------------------------------------- |\n    | Bash              | Inherits | Running terminal commands in a separate context          |\n    | statusline-setup  | Sonnet   | When you run `/statusline` to configure your status line |\n    | Claude Code Guide | Haiku    | When you ask questions about Claude Code features        |\n  </Tab>\n</Tabs>\n\nBeyond these built-in subagents, you can create your own with custom prompts, tool restrictions, permission modes, hooks, and skills. The following sections show how to get started and customize subagents.\n\n## Quickstart: create your first subagent\n\nSubagents are defined in Markdown files with YAML frontmatter. You can [create them manually](#write-subagent-files) or use the `/agents` command.\n\nThis walkthrough guides you through creating a user-level subagent with the `/agent` command. The subagent reviews code and suggests improvements for the codebase.\n\n<Steps>\n  <Step title=\"Open the subagents interface\">\n    In Claude Code, run:\n\n    ```\n    /agents\n    ```\n  </Step>\n\n  <Step title=\"Create a new user-level agent\">\n    Select **Create new agent**, then choose **User-level**. This saves the subagent to `~/.claude/agents/` so it's available in all your projects.\n  </Step>\n\n  <Step title=\"Generate with Claude\">\n    Select **Generate with Claude**. When prompted, describe the subagent:\n\n    ```\n    A code improvement agent that scans files and suggests improvements\n    for readability, performance, and best practices. It should explain\n    each issue, show the current code, and provide an improved version.\n    ```\n\n    Claude generates the system prompt and configuration. Press `e` to open it in your editor if you want to customize it.\n  </Step>\n\n  <Step title=\"Select tools\">\n    For a read-only reviewer, deselect everything except **Read-only tools**. If you keep all tools selected, the subagent inherits all tools available to the main conversation.\n  </Step>\n\n  <Step title=\"Select model\">\n    Choose which model the subagent uses. For this example agent, select **Sonnet**, which balances capability and speed for analyzing code patterns.\n  </Step>\n\n  <Step title=\"Choose a color\">\n    Pick a background color for the subagent. This helps you identify which subagent is running in the UI.\n  </Step>\n\n  <Step title=\"Save and try it out\">\n    Save the subagent. It's available immediately (no restart needed). Try it:\n\n    ```\n    Use the code-improver agent to suggest improvements in this project\n    ```\n\n    Claude delegates to your new subagent, which scans the codebase and returns improvement suggestions.\n  </Step>\n</Steps>\n\nYou now have a subagent you can use in any project on your machine to analyze codebases and suggest improvements.\n\nYou can also create subagents manually as Markdown files, define them via CLI flags, or distribute them through plugins. The following sections cover all configuration options.\n\n## Configure subagents\n\n### Use the /agents command\n\nThe `/agents` command provides an interactive interface for managing subagents. Run `/agents` to:\n\n* View all available subagents (built-in, user, project, and plugin)\n* Create new subagents with guided setup or Claude generation\n* Edit existing subagent configuration and tool access\n* Delete custom subagents\n* See which subagents are active when duplicates exist\n\nThis is the recommended way to create and manage subagents. For manual creation or automation, you can also add subagent files directly.\n\n### Choose the subagent scope\n\nSubagents are Markdown files with YAML frontmatter. Store them in different locations depending on scope. When multiple subagents share the same name, the higher-priority location wins.\n\n| Location                     | Scope                   | Priority    | How to create                         |\n| :--------------------------- | :---------------------- | :---------- | :------------------------------------ |\n| `--agents` CLI flag          | Current session         | 1 (highest) | Pass JSON when launching Claude Code  |\n| `.claude/agents/`            | Current project         | 2           | Interactive or manual                 |\n| `~/.claude/agents/`          | All your projects       | 3           | Interactive or manual                 |\n| Plugin's `agents/` directory | Where plugin is enabled | 4 (lowest)  | Installed with [plugins](/en/plugins) |\n\n**Project subagents** (`.claude/agents/`) are ideal for subagents specific to a codebase. Check them into version control so your team can use and improve them collaboratively.\n\n**User subagents** (`~/.claude/agents/`) are personal subagents available in all your projects.\n\n**CLI-defined subagents** are passed as JSON when launching Claude Code. They exist only for that session and aren't saved to disk, making them useful for quick testing or automation scripts:\n\n```bash  theme={null}\nclaude --agents '{\n  \"code-reviewer\": {\n    \"description\": \"Expert code reviewer. Use proactively after code changes.\",\n    \"prompt\": \"You are a senior code reviewer. Focus on code quality, security, and best practices.\",\n    \"tools\": [\"Read\", \"Grep\", \"Glob\", \"Bash\"],\n    \"model\": \"sonnet\"\n  }\n}'\n```\n\nThe `--agents` flag accepts JSON with the same [frontmatter](#supported-frontmatter-fields) fields as file-based subagents: `description`, `prompt`, `tools`, `disallowedTools`, `model`, `permissionMode`, `mcpServers`, `hooks`, `maxTurns`, `skills`, and `memory`. Use `prompt` for the system prompt, equivalent to the markdown body in file-based subagents. See the [CLI reference](/en/cli-reference#agents-flag-format) for the full JSON format.\n\n**Plugin subagents** come from [plugins](/en/plugins) you've installed. They appear in `/agents` alongside your custom subagents. See the [plugin components reference](/en/plugins-reference#agents) for details on creating plugin subagents.\n\n### Write subagent files\n\nSubagent files use YAML frontmatter for configuration, followed by the system prompt in Markdown:\n\n<Note>\n  Subagents are loaded at session start. If you create a subagent by manually adding a file, restart your session or use `/agents` to load it immediately.\n</Note>\n\n```markdown  theme={null}\n---\nname: code-reviewer\ndescription: Reviews code for quality and best practices\ntools: Read, Glob, Grep\nmodel: sonnet\n---\n\nYou are a code reviewer. When invoked, analyze the code and provide\nspecific, actionable feedback on quality, security, and best practices.\n```\n\nThe frontmatter defines the subagent's metadata and configuration. The body becomes the system prompt that guides the subagent's behavior. Subagents receive only this system prompt (plus basic environment details like working directory), not the full Claude Code system prompt.\n\n#### Supported frontmatter fields\n\nThe following fields can be used in the YAML frontmatter. Only `name` and `description` are required.\n\n| Field             | Required | Description                                                                                                                                                                                                                                                                 |\n| :---------------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `name`            | Yes      | Unique identifier using lowercase letters and hyphens                                                                                                                                                                                                                       |\n| `description`     | Yes      | When Claude should delegate to this subagent                                                                                                                                                                                                                                |\n| `tools`           | No       | [Tools](#available-tools) the subagent can use. Inherits all tools if omitted                                                                                                                                                                                               |\n| `disallowedTools` | No       | Tools to deny, removed from inherited or specified list                                                                                                                                                                                                                     |\n| `model`           | No       | [Model](#choose-a-model) to use: `sonnet`, `opus`, `haiku`, or `inherit`. Defaults to `inherit`                                                                                                                                                                             |\n| `permissionMode`  | No       | [Permission mode](#permission-modes): `default`, `acceptEdits`, `delegate`, `dontAsk`, `bypassPermissions`, or `plan`                                                                                                                                                       |\n| `maxTurns`        | No       | Maximum number of agentic turns before the subagent stops                                                                                                                                                                                                                   |\n| `skills`          | No       | [Skills](/en/skills) to load into the subagent's context at startup. The full skill content is injected, not just made available for invocation. Subagents don't inherit skills from the parent conversation                                                                |\n| `mcpServers`      | No       | [MCP servers](/en/mcp) available to this subagent. Each entry is either a server name referencing an already-configured server (e.g., `\"slack\"`) or an inline definition with the server name as key and a full [MCP server config](/en/mcp#configure-mcp-servers) as value |\n| `hooks`           | No       | [Lifecycle hooks](#define-hooks-for-subagents) scoped to this subagent                                                                                                                                                                                                      |\n| `memory`          | No       | [Persistent memory scope](#enable-persistent-memory): `user`, `project`, or `local`. Enables cross-session learning                                                                                                                                                         |\n\n### Choose a model\n\nThe `model` field controls which [AI model](/en/model-config) the subagent uses:\n\n* **Model alias**: Use one of the available aliases: `sonnet`, `opus`, or `haiku`\n* **inherit**: Use the same model as the main conversation\n* **Omitted**: If not specified, defaults to `inherit` (uses the same model as the main conversation)\n\n### Control subagent capabilities\n\nYou can control what subagents can do through tool access, permission modes, and conditional rules.\n\n#### Available tools\n\nSubagents can use any of Claude Code's [internal tools](/en/settings#tools-available-to-claude). By default, subagents inherit all tools from the main conversation, including MCP tools.\n\nTo restrict tools, use the `tools` field (allowlist) or `disallowedTools` field (denylist):\n\n```yaml  theme={null}\n---\nname: safe-researcher\ndescription: Research agent with restricted capabilities\ntools: Read, Grep, Glob, Bash\ndisallowedTools: Write, Edit\n---\n```\n\n#### Restrict which subagents can be spawned\n\nWhen an agent runs as the main thread with `claude --agent`, it can spawn subagents using the Task tool. To restrict which subagent types it can spawn, use `Task(agent_type)` syntax in the `tools` field:\n\n```yaml  theme={null}\n---\nname: coordinator\ndescription: Coordinates work across specialized agents\ntools: Task(worker, researcher), Read, Bash\n---\n```\n\nThis is an allowlist: only the `worker` and `researcher` subagents can be spawned. If the agent tries to spawn any other type, the request fails and the agent sees only the allowed types in its prompt. To block specific agents while allowing all others, use [`permissions.deny`](#disable-specific-subagents) instead.\n\nTo allow spawning any subagent without restrictions, use `Task` without parentheses:\n\n```yaml  theme={null}\ntools: Task, Read, Bash\n```\n\nIf `Task` is omitted from the `tools` list entirely, the agent cannot spawn any subagents. This restriction only applies to agents running as the main thread with `claude --agent`. Subagents cannot spawn other subagents, so `Task(agent_type)` has no effect in subagent definitions.\n\n#### Permission modes\n\nThe `permissionMode` field controls how the subagent handles permission prompts. Subagents inherit the permission context from the main conversation but can override the mode.\n\n| Mode                | Behavior                                                                                                             |\n| :------------------ | :------------------------------------------------------------------------------------------------------------------- |\n| `default`           | Standard permission checking with prompts                                                                            |\n| `acceptEdits`       | Auto-accept file edits                                                                                               |\n| `dontAsk`           | Auto-deny permission prompts (explicitly allowed tools still work)                                                   |\n| `delegate`          | Coordination-only mode for [agent team](/en/agent-teams#use-delegate-mode) leads. Restricts to team management tools |\n| `bypassPermissions` | Skip all permission checks                                                                                           |\n| `plan`              | Plan mode (read-only exploration)                                                                                    |\n\n<Warning>\n  Use `bypassPermissions` with caution. It skips all permission checks, allowing the subagent to execute any operation without approval.\n</Warning>\n\nIf the parent uses `bypassPermissions`, this takes precedence and cannot be overridden.\n\n#### Preload skills into subagents\n\nUse the `skills` field to inject skill content into a subagent's context at startup. This gives the subagent domain knowledge without requiring it to discover and load skills during execution.\n\n```yaml  theme={null}\n---\nname: api-developer\ndescription: Implement API endpoints following team conventions\nskills:\n  - api-conventions\n  - error-handling-patterns\n---\n\nImplement API endpoints. Follow the conventions and patterns from the preloaded skills.\n```\n\nThe full content of each skill is injected into the subagent's context, not just made available for invocation. Subagents don't inherit skills from the parent conversation; you must list them explicitly.\n\n<Note>\n  This is the inverse of [running a skill in a subagent](/en/skills#run-skills-in-a-subagent). With `skills` in a subagent, the subagent controls the system prompt and loads skill content. With `context: fork` in a skill, the skill content is injected into the agent you specify. Both use the same underlying system.\n</Note>\n\n#### Enable persistent memory\n\nThe `memory` field gives the subagent a persistent directory that survives across conversations. The subagent uses this directory to build up knowledge over time, such as codebase patterns, debugging insights, and architectural decisions.\n\n```yaml  theme={null}\n---\nname: code-reviewer\ndescription: Reviews code for quality and best practices\nmemory: user\n---\n\nYou are a code reviewer. As you review code, update your agent memory with\npatterns, conventions, and recurring issues you discover.\n```\n\nChoose a scope based on how broadly the memory should apply:\n\n| Scope     | Location                                      | Use when                                                                                    |\n| :-------- | :-------------------------------------------- | :------------------------------------------------------------------------------------------ |\n| `user`    | `~/.claude/agent-memory/<name-of-agent>/`     | the subagent should remember learnings across all projects                                  |\n| `project` | `.claude/agent-memory/<name-of-agent>/`       | the subagent's knowledge is project-specific and shareable via version control              |\n| `local`   | `.claude/agent-memory-local/<name-of-agent>/` | the subagent's knowledge is project-specific but should not be checked into version control |\n\nWhen memory is enabled:\n\n* The subagent's system prompt includes instructions for reading and writing to the memory directory.\n* The subagent's system prompt also includes the first 200 lines of `MEMORY.md` in the memory directory, with instructions to curate `MEMORY.md` if it exceeds 200 lines.\n* Read, Write, and Edit tools are automatically enabled so the subagent can manage its memory files.\n\n##### Persistent memory tips\n\n* `user` is the recommended default scope. Use `project` or `local` when the subagent's knowledge is only relevant to a specific codebase.\n* Ask the subagent to consult its memory before starting work: \"Review this PR, and check your memory for patterns you've seen before.\"\n* Ask the subagent to update its memory after completing a task: \"Now that you're done, save what you learned to your memory.\" Over time, this builds a knowledge base that makes the subagent more effective.\n* Include memory instructions directly in the subagent's markdown file so it proactively maintains its own knowledge base:\n\n  ```markdown  theme={null}\n  Update your agent memory as you discover codepaths, patterns, library\n  locations, and key architectural decisions. This builds up institutional\n  knowledge across conversations. Write concise notes about what you found\n  and where.\n  ```\n\n#### Conditional rules with hooks\n\nFor more dynamic control over tool usage, use `PreToolUse` hooks to validate operations before they execute. This is useful when you need to allow some operations of a tool while blocking others.\n\nThis example creates a subagent that only allows read-only database queries. The `PreToolUse` hook runs the script specified in `command` before each Bash command executes:\n\n```yaml  theme={null}\n---\nname: db-reader\ndescription: Execute read-only database queries\ntools: Bash\nhooks:\n  PreToolUse:\n    - matcher: \"Bash\"\n      hooks:\n        - type: command\n          command: \"./scripts/validate-readonly-query.sh\"\n---\n```\n\nClaude Code [passes hook input as JSON](/en/hooks#pretooluse-input) via stdin to hook commands. The validation script reads this JSON, extracts the Bash command, and [exits with code 2](/en/hooks#exit-code-2-behavior-per-event) to block write operations:\n\n```bash  theme={null}\n#!/bin/bash\n# ./scripts/validate-readonly-query.sh\n\nINPUT=$(cat)\nCOMMAND=$(echo \"$INPUT\" | jq -r '.tool_input.command // empty')\n\n# Block SQL write operations (case-insensitive)\nif echo \"$COMMAND\" | grep -iE '\\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE)\\b' > /dev/null; then\n  echo \"Blocked: Only SELECT queries are allowed\" >&2\n  exit 2\nfi\n\nexit 0\n```\n\nSee [Hook input](/en/hooks#pretooluse-input) for the complete input schema and [exit codes](/en/hooks#exit-code-output) for how exit codes affect behavior.\n\n#### Disable specific subagents\n\nYou can prevent Claude from using specific subagents by adding them to the `deny` array in your [settings](/en/settings#permission-settings). Use the format `Task(subagent-name)` where `subagent-name` matches the subagent's name field.\n\n```json  theme={null}\n{\n  \"permissions\": {\n    \"deny\": [\"Task(Explore)\", \"Task(my-custom-agent)\"]\n  }\n}\n```\n\nThis works for both built-in and custom subagents. You can also use the `--disallowedTools` CLI flag:\n\n```bash  theme={null}\nclaude --disallowedTools \"Task(Explore)\"\n```\n\nSee [Permissions documentation](/en/permissions#tool-specific-permission-rules) for more details on permission rules.\n\n### Define hooks for subagents\n\nSubagents can define [hooks](/en/hooks) that run during the subagent's lifecycle. There are two ways to configure hooks:\n\n1. **In the subagent's frontmatter**: Define hooks that run only while that subagent is active\n2. **In `settings.json`**: Define hooks that run in the main session when subagents start or stop\n\n#### Hooks in subagent frontmatter\n\nDefine hooks directly in the subagent's markdown file. These hooks only run while that specific subagent is active and are cleaned up when it finishes.\n\nAll [hook events](/en/hooks#hook-events) are supported. The most common events for subagents are:\n\n| Event         | Matcher input | When it fires                                                       |\n| :------------ | :------------ | :------------------------------------------------------------------ |\n| `PreToolUse`  | Tool name     | Before the subagent uses a tool                                     |\n| `PostToolUse` | Tool name     | After the subagent uses a tool                                      |\n| `Stop`        | (none)        | When the subagent finishes (converted to `SubagentStop` at runtime) |\n\nThis example validates Bash commands with the `PreToolUse` hook and runs a linter after file edits with `PostToolUse`:\n\n```yaml  theme={null}\n---\nname: code-reviewer\ndescription: Review code changes with automatic linting\nhooks:\n  PreToolUse:\n    - matcher: \"Bash\"\n      hooks:\n        - type: command\n          command: \"./scripts/validate-command.sh $TOOL_INPUT\"\n  PostToolUse:\n    - matcher: \"Edit|Write\"\n      hooks:\n        - type: command\n          command: \"./scripts/run-linter.sh\"\n---\n```\n\n`Stop` hooks in frontmatter are automatically converted to `SubagentStop` events.\n\n#### Project-level hooks for subagent events\n\nConfigure hooks in `settings.json` that respond to subagent lifecycle events in the main session.\n\n| Event           | Matcher input   | When it fires                    |\n| :-------------- | :-------------- | :------------------------------- |\n| `SubagentStart` | Agent type name | When a subagent begins execution |\n| `SubagentStop`  | Agent type name | When a subagent completes        |\n\nBoth events support matchers to target specific agent types by name. This example runs a setup script only when the `db-agent` subagent starts, and a cleanup script when any subagent stops:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"SubagentStart\": [\n      {\n        \"matcher\": \"db-agent\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"./scripts/setup-db-connection.sh\" }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"./scripts/cleanup-db-connection.sh\" }\n        ]\n      }\n    ]\n  }\n}\n```\n\nSee [Hooks](/en/hooks) for the complete hook configuration format.\n\n## Work with subagents\n\n### Understand automatic delegation\n\nClaude automatically delegates tasks based on the task description in your request, the `description` field in subagent configurations, and current context. To encourage proactive delegation, include phrases like \"use proactively\" in your subagent's description field.\n\nYou can also request a specific subagent explicitly:\n\n```\nUse the test-runner subagent to fix failing tests\nHave the code-reviewer subagent look at my recent changes\n```\n\n### Run subagents in foreground or background\n\nSubagents can run in the foreground (blocking) or background (concurrent):\n\n* **Foreground subagents** block the main conversation until complete. Permission prompts and clarifying questions (like [`AskUserQuestion`](/en/settings#tools-available-to-claude)) are passed through to you.\n* **Background subagents** run concurrently while you continue working. Before launching, Claude Code prompts for any tool permissions the subagent will need, ensuring it has the necessary approvals upfront. Once running, the subagent inherits these permissions and auto-denies anything not pre-approved. If a background subagent needs to ask clarifying questions, that tool call fails but the subagent continues. MCP tools are not available in background subagents.\n\nIf a background subagent fails due to missing permissions, you can [resume it](#resume-subagents) in the foreground to retry with interactive prompts.\n\nClaude decides whether to run subagents in the foreground or background based on the task. You can also:\n\n* Ask Claude to \"run this in the background\"\n* Press **Ctrl+B** to background a running task\n\nTo disable all background task functionality, set the `CLAUDE_CODE_DISABLE_BACKGROUND_TASKS` environment variable to `1`. See [Environment variables](/en/settings#environment-variables).\n\n### Common patterns\n\n#### Isolate high-volume operations\n\nOne of the most effective uses for subagents is isolating operations that produce large amounts of output. Running tests, fetching documentation, or processing log files can consume significant context. By delegating these to a subagent, the verbose output stays in the subagent's context while only the relevant summary returns to your main conversation.\n\n```\nUse a subagent to run the test suite and report only the failing tests with their error messages\n```\n\n#### Run parallel research\n\nFor independent investigations, spawn multiple subagents to work simultaneously:\n\n```\nResearch the authentication, database, and API modules in parallel using separate subagents\n```\n\nEach subagent explores its area independently, then Claude synthesizes the findings. This works best when the research paths don't depend on each other.\n\n<Warning>\n  When subagents complete, their results return to your main conversation. Running many subagents that each return detailed results can consume significant context.\n</Warning>\n\nFor tasks that need sustained parallelism or exceed your context window, [agent teams](/en/agent-teams) give each worker its own independent context.\n\n#### Chain subagents\n\nFor multi-step workflows, ask Claude to use subagents in sequence. Each subagent completes its task and returns results to Claude, which then passes relevant context to the next subagent.\n\n```\nUse the code-reviewer subagent to find performance issues, then use the optimizer subagent to fix them\n```\n\n### Choose between subagents and main conversation\n\nUse the **main conversation** when:\n\n* The task needs frequent back-and-forth or iterative refinement\n* Multiple phases share significant context (planning  implementation  testing)\n* You're making a quick, targeted change\n* Latency matters. Subagents start fresh and may need time to gather context\n\nUse **subagents** when:\n\n* The task produces verbose output you don't need in your main context\n* You want to enforce specific tool restrictions or permissions\n* The work is self-contained and can return a summary\n\nConsider [Skills](/en/skills) instead when you want reusable prompts or workflows that run in the main conversation context rather than isolated subagent context.\n\n<Note>\n  Subagents cannot spawn other subagents. If your workflow requires nested delegation, use [Skills](/en/skills) or [chain subagents](#chain-subagents) from the main conversation.\n</Note>\n\n### Manage subagent context\n\n#### Resume subagents\n\nEach subagent invocation creates a new instance with fresh context. To continue an existing subagent's work instead of starting over, ask Claude to resume it.\n\nResumed subagents retain their full conversation history, including all previous tool calls, results, and reasoning. The subagent picks up exactly where it stopped rather than starting fresh.\n\nWhen a subagent completes, Claude receives its agent ID. To resume a subagent, ask Claude to continue the previous work:\n\n```\nUse the code-reviewer subagent to review the authentication module\n[Agent completes]\n\nContinue that code review and now analyze the authorization logic\n[Claude resumes the subagent with full context from previous conversation]\n```\n\nYou can also ask Claude for the agent ID if you want to reference it explicitly, or find IDs in the transcript files at `~/.claude/projects/{project}/{sessionId}/subagents/`. Each transcript is stored as `agent-{agentId}.jsonl`.\n\nSubagent transcripts persist independently of the main conversation:\n\n* **Main conversation compaction**: When the main conversation compacts, subagent transcripts are unaffected. They're stored in separate files.\n* **Session persistence**: Subagent transcripts persist within their session. You can [resume a subagent](#resume-subagents) after restarting Claude Code by resuming the same session.\n* **Automatic cleanup**: Transcripts are cleaned up based on the `cleanupPeriodDays` setting (default: 30 days).\n\n#### Auto-compaction\n\nSubagents support automatic compaction using the same logic as the main conversation. By default, auto-compaction triggers at approximately 95% capacity. To trigger compaction earlier, set `CLAUDE_AUTOCOMPACT_PCT_OVERRIDE` to a lower percentage (for example, `50`). See [environment variables](/en/settings#environment-variables) for details.\n\nCompaction events are logged in subagent transcript files:\n\n```json  theme={null}\n{\n  \"type\": \"system\",\n  \"subtype\": \"compact_boundary\",\n  \"compactMetadata\": {\n    \"trigger\": \"auto\",\n    \"preTokens\": 167189\n  }\n}\n```\n\nThe `preTokens` value shows how many tokens were used before compaction occurred.\n\n## Example subagents\n\nThese examples demonstrate effective patterns for building subagents. Use them as starting points, or generate a customized version with Claude.\n\n<Tip>\n  **Best practices:**\n\n  * **Design focused subagents:** each subagent should excel at one specific task\n  * **Write detailed descriptions:** Claude uses the description to decide when to delegate\n  * **Limit tool access:** grant only necessary permissions for security and focus\n  * **Check into version control:** share project subagents with your team\n</Tip>\n\n### Code reviewer\n\nA read-only subagent that reviews code without modifying it. This example shows how to design a focused subagent with limited tool access (no Edit or Write) and a detailed prompt that specifies exactly what to look for and how to format output.\n\n```markdown  theme={null}\n---\nname: code-reviewer\ndescription: Expert code review specialist. Proactively reviews code for quality, security, and maintainability. Use immediately after writing or modifying code.\ntools: Read, Grep, Glob, Bash\nmodel: inherit\n---\n\nYou are a senior code reviewer ensuring high standards of code quality and security.\n\nWhen invoked:\n1. Run git diff to see recent changes\n2. Focus on modified files\n3. Begin review immediately\n\nReview checklist:\n- Code is clear and readable\n- Functions and variables are well-named\n- No duplicated code\n- Proper error handling\n- No exposed secrets or API keys\n- Input validation implemented\n- Good test coverage\n- Performance considerations addressed\n\nProvide feedback organized by priority:\n- Critical issues (must fix)\n- Warnings (should fix)\n- Suggestions (consider improving)\n\nInclude specific examples of how to fix issues.\n```\n\n### Debugger\n\nA subagent that can both analyze and fix issues. Unlike the code reviewer, this one includes Edit because fixing bugs requires modifying code. The prompt provides a clear workflow from diagnosis to verification.\n\n```markdown  theme={null}\n---\nname: debugger\ndescription: Debugging specialist for errors, test failures, and unexpected behavior. Use proactively when encountering any issues.\ntools: Read, Edit, Bash, Grep, Glob\n---\n\nYou are an expert debugger specializing in root cause analysis.\n\nWhen invoked:\n1. Capture error message and stack trace\n2. Identify reproduction steps\n3. Isolate the failure location\n4. Implement minimal fix\n5. Verify solution works\n\nDebugging process:\n- Analyze error messages and logs\n- Check recent code changes\n- Form and test hypotheses\n- Add strategic debug logging\n- Inspect variable states\n\nFor each issue, provide:\n- Root cause explanation\n- Evidence supporting the diagnosis\n- Specific code fix\n- Testing approach\n- Prevention recommendations\n\nFocus on fixing the underlying issue, not the symptoms.\n```\n\n### Data scientist\n\nA domain-specific subagent for data analysis work. This example shows how to create subagents for specialized workflows outside of typical coding tasks. It explicitly sets `model: sonnet` for more capable analysis.\n\n```markdown  theme={null}\n---\nname: data-scientist\ndescription: Data analysis expert for SQL queries, BigQuery operations, and data insights. Use proactively for data analysis tasks and queries.\ntools: Bash, Read, Write\nmodel: sonnet\n---\n\nYou are a data scientist specializing in SQL and BigQuery analysis.\n\nWhen invoked:\n1. Understand the data analysis requirement\n2. Write efficient SQL queries\n3. Use BigQuery command line tools (bq) when appropriate\n4. Analyze and summarize results\n5. Present findings clearly\n\nKey practices:\n- Write optimized SQL queries with proper filters\n- Use appropriate aggregations and joins\n- Include comments explaining complex logic\n- Format results for readability\n- Provide data-driven recommendations\n\nFor each analysis:\n- Explain the query approach\n- Document any assumptions\n- Highlight key findings\n- Suggest next steps based on data\n\nAlways ensure queries are efficient and cost-effective.\n```\n\n### Database query validator\n\nA subagent that allows Bash access but validates commands to permit only read-only SQL queries. This example shows how to use `PreToolUse` hooks for conditional validation when you need finer control than the `tools` field provides.\n\n```markdown  theme={null}\n---\nname: db-reader\ndescription: Execute read-only database queries. Use when analyzing data or generating reports.\ntools: Bash\nhooks:\n  PreToolUse:\n    - matcher: \"Bash\"\n      hooks:\n        - type: command\n          command: \"./scripts/validate-readonly-query.sh\"\n---\n\nYou are a database analyst with read-only access. Execute SELECT queries to answer questions about the data.\n\nWhen asked to analyze data:\n1. Identify which tables contain the relevant data\n2. Write efficient SELECT queries with appropriate filters\n3. Present results clearly with context\n\nYou cannot modify data. If asked to INSERT, UPDATE, DELETE, or modify schema, explain that you only have read access.\n```\n\nClaude Code [passes hook input as JSON](/en/hooks#pretooluse-input) via stdin to hook commands. The validation script reads this JSON, extracts the command being executed, and checks it against a list of SQL write operations. If a write operation is detected, the script [exits with code 2](/en/hooks#exit-code-2-behavior-per-event) to block execution and returns an error message to Claude via stderr.\n\nCreate the validation script anywhere in your project. The path must match the `command` field in your hook configuration:\n\n```bash  theme={null}\n#!/bin/bash\n# Blocks SQL write operations, allows SELECT queries\n\n# Read JSON input from stdin\nINPUT=$(cat)\n\n# Extract the command field from tool_input using jq\nCOMMAND=$(echo \"$INPUT\" | jq -r '.tool_input.command // empty')\n\nif [ -z \"$COMMAND\" ]; then\n  exit 0\nfi\n\n# Block write operations (case-insensitive)\nif echo \"$COMMAND\" | grep -iE '\\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE|MERGE)\\b' > /dev/null; then\n  echo \"Blocked: Write operations not allowed. Use SELECT queries only.\" >&2\n  exit 2\nfi\n\nexit 0\n```\n\nMake the script executable:\n\n```bash  theme={null}\nchmod +x ./scripts/validate-readonly-query.sh\n```\n\nThe hook receives JSON via stdin with the Bash command in `tool_input.command`. Exit code 2 blocks the operation and feeds the error message back to Claude. See [Hooks](/en/hooks#exit-code-output) for details on exit codes and [Hook input](/en/hooks#pretooluse-input) for the complete input schema.\n\n## Next steps\n\nNow that you understand subagents, explore these related features:\n\n* [Distribute subagents with plugins](/en/plugins) to share subagents across teams or projects\n* [Run Claude Code programmatically](/en/headless) with the Agent SDK for CI/CD and automation\n* [Use MCP servers](/en/mcp) to give subagents access to external tools and data\n"}]},"uuid":"b7d4bf79-6af6-4b62-ada1-fe1f797d70d9","timestamp":"2026-02-16T21:52:59.881Z","sourceToolAssistantUUID":"dabc32e5-ceee-4441-85bf-4878799bf9a4"}
{"parentUuid":"dfec715e-486a-4e31-b737-9bde5792e3b3","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HhPLbJmewb619qVCi5fAo6","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# Orchestrate teams of Claude Code sessions\n\n> Coordinate multiple Claude Code instances working together as a team, with shared tasks, inter-agent messaging, and centralized management.\n\n<Warning>\n  Agent teams are experimental and disabled by default. Enable them by adding `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` to your [settings.json](/en/settings) or environment. Agent teams have [known limitations](#limitations) around session resumption, task coordination, and shutdown behavior.\n</Warning>\n\nAgent teams let you coordinate multiple Claude Code instances working together. One session acts as the team lead, coordinating work, assigning tasks, and synthesizing results. Teammates work independently, each in its own context window, and communicate directly with each other.\n\nUnlike [subagents](/en/sub-agents), which run within a single session and can only report back to the main agent, you can also interact with individual teammates directly without going through the lead.\n\nThis page covers:\n\n* [When to use agent teams](#when-to-use-agent-teams), including best use cases and how they compare with subagents\n* [Starting a team](#start-your-first-agent-team)\n* [Controlling teammates](#control-your-agent-team), including display modes, task assignment, and delegation\n* [Best practices for parallel work](#best-practices)\n\n## When to use agent teams\n\nAgent teams are most effective for tasks where parallel exploration adds real value. See [use case examples](#use-case-examples) for full scenarios. The strongest use cases are:\n\n* **Research and review**: multiple teammates can investigate different aspects of a problem simultaneously, then share and challenge each other's findings\n* **New modules or features**: teammates can each own a separate piece without stepping on each other\n* **Debugging with competing hypotheses**: teammates test different theories in parallel and converge on the answer faster\n* **Cross-layer coordination**: changes that span frontend, backend, and tests, each owned by a different teammate\n\nAgent teams add coordination overhead and use significantly more tokens than a single session. They work best when teammates can operate independently. For sequential tasks, same-file edits, or work with many dependencies, a single session or [subagents](/en/sub-agents) are more effective.\n\n### Compare with subagents\n\nBoth agent teams and [subagents](/en/sub-agents) let you parallelize work, but they operate differently. Choose based on whether your workers need to communicate with each other:\n\n<Frame caption=\"Subagents only report results back to the main agent and never talk to each other. In agent teams, teammates share a task list, claim work, and communicate directly with each other.\">\n  <img src=\"https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=2f8db9b4f3705dd3ab931fbe2d96e42a\" className=\"dark:hidden\" alt=\"Diagram comparing subagent and agent team architectures. Subagents are spawned by the main agent, do work, and report results back. Agent teams coordinate through a shared task list, with teammates communicating directly with each other.\" data-og-width=\"4245\" width=\"4245\" data-og-height=\"1615\" height=\"1615\" data-path=\"images/subagents-vs-agent-teams-light.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=280&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=a2cfe413c2084b477be40ac8723d9d40 280w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=560&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=c642c09a4c211b10b35eee7d7d0d149f 560w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=840&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=40d286f77c8a4075346b4fcaa2b36248 840w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=1100&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=923986caa23c0ef2c27d7e45f4dce6d1 1100w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=1650&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=17a730a070db6d71d029a98b074c68e8 1650w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-light.png?w=2500&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=e402533fc9e8b5e8d26a835cc4aa1742 2500w\" />\n\n  <img src=\"https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=d573a037540f2ada6a9ae7d8285b46fd\" className=\"hidden dark:block\" alt=\"Diagram comparing subagent and agent team architectures. Subagents are spawned by the main agent, do work, and report results back. Agent teams coordinate through a shared task list, with teammates communicating directly with each other.\" data-og-width=\"4245\" width=\"4245\" data-og-height=\"1615\" height=\"1615\" data-path=\"images/subagents-vs-agent-teams-dark.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=280&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=06ca5b18b232855acc488357d8d01fa7 280w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=560&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=3d34daee83994781eb74b74d1ed511c4 560w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=840&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=82ea35ac837de7d674002de69689b9cf 840w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=1100&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=3653085214a9fc65d1f589044894a296 1100w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=1650&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=8e74b42694e428570e876d34f29e6ad6 1650w, https://mintcdn.com/claude-code/nsvRFSDNfpSU5nT7/images/subagents-vs-agent-teams-dark.png?w=2500&fit=max&auto=format&n=nsvRFSDNfpSU5nT7&q=85&s=3be00c56c6a0dcccbe15640020be0128 2500w\" />\n</Frame>\n\n|                   | Subagents                                        | Agent teams                                         |\n| :---------------- | :----------------------------------------------- | :-------------------------------------------------- |\n| **Context**       | Own context window; results return to the caller | Own context window; fully independent               |\n| **Communication** | Report results back to the main agent only       | Teammates message each other directly               |\n| **Coordination**  | Main agent manages all work                      | Shared task list with self-coordination             |\n| **Best for**      | Focused tasks where only the result matters      | Complex work requiring discussion and collaboration |\n| **Token cost**    | Lower: results summarized back to main context   | Higher: each teammate is a separate Claude instance |\n\nUse subagents when you need quick, focused workers that report back. Use agent teams when teammates need to share findings, challenge each other, and coordinate on their own.\n\n## Enable agent teams\n\nAgent teams are disabled by default. Enable them by setting the `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` environment variable to `1`, either in your shell environment or through [settings.json](/en/settings):\n\n```json settings.json theme={null}\n{\n  \"env\": {\n    \"CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS\": \"1\"\n  }\n}\n```\n\n## Start your first agent team\n\nAfter enabling agent teams, tell Claude to create an agent team and describe the task and the team structure you want in natural language. Claude creates the team, spawns teammates, and coordinates work based on your prompt.\n\nThis example works well because the three roles are independent and can explore the problem without waiting on each other:\n\n```\nI'm designing a CLI tool that helps developers track TODO comments across\ntheir codebase. Create an agent team to explore this from different angles: one\nteammate on UX, one on technical architecture, one playing devil's advocate.\n```\n\nFrom there, Claude creates a team with a [shared task list](/en/interactive-mode#task-list), spawns teammates for each perspective, has them explore the problem, synthesizes findings, and attempts to [clean up the team](#clean-up-the-team) when finished.\n\nThe lead's terminal lists all teammates and what they're working on. Use Shift+Up/Down to select a teammate and message them directly.\n\nIf you want each teammate in its own split pane, see [Choose a display mode](#choose-a-display-mode).\n\n## Control your agent team\n\nTell the lead what you want in natural language. It handles team coordination, task assignment, and delegation based on your instructions.\n\n### Choose a display mode\n\nAgent teams support two display modes:\n\n* **In-process**: all teammates run inside your main terminal. Use Shift+Up/Down to select a teammate and type to message them directly. Works in any terminal, no extra setup required.\n* **Split panes**: each teammate gets its own pane. You can see everyone's output at once and click into a pane to interact directly. Requires tmux, or iTerm2.\n\n<Note>\n  `tmux` has known limitations on certain operating systems and traditionally works best on macOS. Using `tmux -CC` in iTerm2 is the suggested entrypoint into `tmux`.\n</Note>\n\nThe default is `\"auto\"`, which uses split panes if you're already running inside a tmux session, and in-process otherwise. The `\"tmux\"` setting enables split-pane mode and auto-detects whether to use tmux or iTerm2 based on your terminal. To override, set `teammateMode` in your [settings.json](/en/settings):\n\n```json  theme={null}\n{\n  \"teammateMode\": \"in-process\"\n}\n```\n\nTo force in-process mode for a single session, pass it as a flag:\n\n```bash  theme={null}\nclaude --teammate-mode in-process\n```\n\nSplit-pane mode requires either [tmux](https://github.com/tmux/tmux/wiki) or iTerm2 with the [`it2` CLI](https://github.com/mkusaka/it2). To install manually:\n\n* **tmux**: install through your system's package manager. See the [tmux wiki](https://github.com/tmux/tmux/wiki/Installing) for platform-specific instructions.\n* **iTerm2**: install the [`it2` CLI](https://github.com/mkusaka/it2), then enable the Python API in **iTerm2  Settings  General  Magic  Enable Python API**.\n\n### Specify teammates and models\n\nClaude decides the number of teammates to spawn based on your task, or you can specify exactly what you want:\n\n```\nCreate a team with 4 teammates to refactor these modules in parallel.\nUse Sonnet for each teammate.\n```\n\n### Require plan approval for teammates\n\nFor complex or risky tasks, you can require teammates to plan before implementing. The teammate works in read-only plan mode until the lead approves their approach:\n\n```\nSpawn an architect teammate to refactor the authentication module.\nRequire plan approval before they make any changes.\n```\n\nWhen a teammate finishes planning, it sends a plan approval request to the lead. The lead reviews the plan and either approves it or rejects it with feedback. If rejected, the teammate stays in plan mode, revises based on the feedback, and resubmits. Once approved, the teammate exits plan mode and begins implementation.\n\nThe lead makes approval decisions autonomously. To influence the lead's judgment, give it criteria in your prompt, such as \"only approve plans that include test coverage\" or \"reject plans that modify the database schema.\"\n\n### Use delegate mode\n\nWithout delegate mode, the lead sometimes starts implementing tasks itself instead of waiting for teammates. Delegate mode prevents this by restricting the lead to coordination-only tools: spawning, messaging, shutting down teammates, and managing tasks.\n\nThis is useful when you want the lead to focus entirely on orchestration, such as breaking down work, assigning tasks, and synthesizing results, without touching code directly.\n\nTo enable it, start a team first, then press Shift+Tab to cycle into delegate mode.\n\n### Talk to teammates directly\n\nEach teammate is a full, independent Claude Code session. You can message any teammate directly to give additional instructions, ask follow-up questions, or redirect their approach.\n\n* **In-process mode**: use Shift+Up/Down to select a teammate, then type to send them a message. Press Enter to view a teammate's session, then Escape to interrupt their current turn. Press Ctrl+T to toggle the task list.\n* **Split-pane mode**: click into a teammate's pane to interact with their session directly. Each teammate has a full view of their own terminal.\n\n### Assign and claim tasks\n\nThe shared task list coordinates work across the team. The lead creates tasks and teammates work through them. Tasks have three states: pending, in progress, and completed. Tasks can also depend on other tasks: a pending task with unresolved dependencies cannot be claimed until those dependencies are completed.\n\nThe lead can assign tasks explicitly, or teammates can self-claim:\n\n* **Lead assigns**: tell the lead which task to give to which teammate\n* **Self-claim**: after finishing a task, a teammate picks up the next unassigned, unblocked task on its own\n\nTask claiming uses file locking to prevent race conditions when multiple teammates try to claim the same task simultaneously.\n\n### Shut down teammates\n\nTo gracefully end a teammate's session:\n\n```\nAsk the researcher teammate to shut down\n```\n\nThe lead sends a shutdown request. The teammate can approve, exiting gracefully, or reject with an explanation.\n\n### Clean up the team\n\nWhen you're done, ask the lead to clean up:\n\n```\nClean up the team\n```\n\nThis removes the shared team resources. When the lead runs cleanup, it checks for active teammates and fails if any are still running, so shut them down first.\n\n<Warning>\n  Always use the lead to clean up. Teammates should not run cleanup because their team context may not resolve correctly, potentially leaving resources in an inconsistent state.\n</Warning>\n\n### Enforce quality gates with hooks\n\nUse [hooks](/en/hooks) to enforce rules when teammates finish work or tasks complete:\n\n* [`TeammateIdle`](/en/hooks#teammateidle): runs when a teammate is about to go idle. Exit with code 2 to send feedback and keep the teammate working.\n* [`TaskCompleted`](/en/hooks#taskcompleted): runs when a task is being marked complete. Exit with code 2 to prevent completion and send feedback.\n\n## How agent teams work\n\nThis section covers the architecture and mechanics behind agent teams. If you want to start using them, see [Control your agent team](#control-your-agent-team) above.\n\n### How Claude starts agent teams\n\nThere are two ways agent teams get started:\n\n* **You request a team**: give Claude a task that benefits from parallel work and explicitly ask for an agent team. Claude creates one based on your instructions.\n* **Claude proposes a team**: if Claude determines your task would benefit from parallel work, it may suggest creating a team. You confirm before it proceeds.\n\nIn both cases, you stay in control. Claude won't create a team without your approval.\n\n### Architecture\n\nAn agent team consists of:\n\n| Component     | Role                                                                                       |\n| :------------ | :----------------------------------------------------------------------------------------- |\n| **Team lead** | The main Claude Code session that creates the team, spawns teammates, and coordinates work |\n| **Teammates** | Separate Claude Code instances that each work on assigned tasks                            |\n| **Task list** | Shared list of work items that teammates claim and complete                                |\n| **Mailbox**   | Messaging system for communication between agents                                          |\n\nSee [Choose a display mode](#choose-a-display-mode) for display configuration options. Teammate messages arrive at the lead automatically.\n\nThe system manages task dependencies automatically. When a teammate completes a task that other tasks depend on, blocked tasks unblock without manual intervention.\n\nTeams and tasks are stored locally:\n\n* **Team config**: `~/.claude/teams/{team-name}/config.json`\n* **Task list**: `~/.claude/tasks/{team-name}/`\n\nThe team config contains a `members` array with each teammate's name, agent ID, and agent type. Teammates can read this file to discover other team members.\n\n### Permissions\n\nTeammates start with the lead's permission settings. If the lead runs with `--dangerously-skip-permissions`, all teammates do too. After spawning, you can change individual teammate modes, but you can't set per-teammate modes at spawn time.\n\n### Context and communication\n\nEach teammate has its own context window. When spawned, a teammate loads the same project context as a regular session: CLAUDE.md, MCP servers, and skills. It also receives the spawn prompt from the lead. The lead's conversation history does not carry over.\n\n**How teammates share information:**\n\n* **Automatic message delivery**: when teammates send messages, they're delivered automatically to recipients. The lead doesn't need to poll for updates.\n* **Idle notifications**: when a teammate finishes and stops, they automatically notify the lead.\n* **Shared task list**: all agents can see task status and claim available work.\n\n**Teammate messaging:**\n\n* **message**: send a message to one specific teammate\n* **broadcast**: send to all teammates simultaneously. Use sparingly, as costs scale with team size.\n\n### Token usage\n\nAgent teams use significantly more tokens than a single session. Each teammate has its own context window, and token usage scales with the number of active teammates. For research, review, and new feature work, the extra tokens are usually worthwhile. For routine tasks, a single session is more cost-effective. See [agent team token costs](/en/costs#agent-team-token-costs) for usage guidance.\n\n## Use case examples\n\nThese examples show how agent teams handle tasks where parallel exploration adds value.\n\n### Run a parallel code review\n\nA single reviewer tends to gravitate toward one type of issue at a time. Splitting review criteria into independent domains means security, performance, and test coverage all get thorough attention simultaneously. The prompt assigns each teammate a distinct lens so they don't overlap:\n\n```\nCreate an agent team to review PR #142. Spawn three reviewers:\n- One focused on security implications\n- One checking performance impact\n- One validating test coverage\nHave them each review and report findings.\n```\n\nEach reviewer works from the same PR but applies a different filter. The lead synthesizes findings across all three after they finish.\n\n### Investigate with competing hypotheses\n\nWhen the root cause is unclear, a single agent tends to find one plausible explanation and stop looking. The prompt fights this by making teammates explicitly adversarial: each one's job is not only to investigate its own theory but to challenge the others'.\n\n```\nUsers report the app exits after one message instead of staying connected.\nSpawn 5 agent teammates to investigate different hypotheses. Have them talk to\neach other to try to disprove each other's theories, like a scientific\ndebate. Update the findings doc with whatever consensus emerges.\n```\n\nThe debate structure is the key mechanism here. Sequential investigation suffers from anchoring: once one theory is explored, subsequent investigation is biased toward it.\n\nWith multiple independent investigators actively trying to disprove each other, the theory that survives is much more likely to be the actual root cause.\n\n## Best practices\n\n### Give teammates enough context\n\nTeammates load project context automatically, including CLAUDE.md, MCP servers, and skills, but they don't inherit the lead's conversation history. See [Context and communication](#context-and-communication) for details. Include task-specific details in the spawn prompt:\n\n```\nSpawn a security reviewer teammate with the prompt: \"Review the authentication module\nat src/auth/ for security vulnerabilities. Focus on token handling, session\nmanagement, and input validation. The app uses JWT tokens stored in\nhttpOnly cookies. Report any issues with severity ratings.\"\n```\n\n### Size tasks appropriately\n\n* **Too small**: coordination overhead exceeds the benefit\n* **Too large**: teammates work too long without check-ins, increasing risk of wasted effort\n* **Just right**: self-contained units that produce a clear deliverable, such as a function, a test file, or a review\n\n<Tip>\n  The lead breaks work into tasks and assigns them to teammates automatically. If it isn't creating enough tasks, ask it to split the work into smaller pieces. Having 5-6 tasks per teammate keeps everyone productive and lets the lead reassign work if someone gets stuck.\n</Tip>\n\n### Wait for teammates to finish\n\nSometimes the lead starts implementing tasks itself instead of waiting for teammates. If you notice this:\n\n```\nWait for your teammates to complete their tasks before proceeding\n```\n\n### Start with research and review\n\nIf you're new to agent teams, start with tasks that have clear boundaries and don't require writing code: reviewing a PR, researching a library, or investigating a bug. These tasks show the value of parallel exploration without the coordination challenges that come with parallel implementation.\n\n### Avoid file conflicts\n\nTwo teammates editing the same file leads to overwrites. Break the work so each teammate owns a different set of files.\n\n### Monitor and steer\n\nCheck in on teammates' progress, redirect approaches that aren't working, and synthesize findings as they come in. Letting a team run unattended for too long increases the risk of wasted effort.\n\n## Troubleshooting\n\n### Teammates not appearing\n\nIf teammates aren't appearing after you ask Claude to create a team:\n\n* In in-process mode, teammates may already be running but not visible. Press Shift+Down to cycle through active teammates.\n* Check that the task you gave Claude was complex enough to warrant a team. Claude decides whether to spawn teammates based on the task.\n* If you explicitly requested split panes, ensure tmux is installed and available in your PATH:\n  ```bash  theme={null}\n  which tmux\n  ```\n* For iTerm2, verify the `it2` CLI is installed and the Python API is enabled in iTerm2 preferences.\n\n### Too many permission prompts\n\nTeammate permission requests bubble up to the lead, which can create friction. Pre-approve common operations in your [permission settings](/en/permissions) before spawning teammates to reduce interruptions.\n\n### Teammates stopping on errors\n\nTeammates may stop after encountering errors instead of recovering. Check their output using Shift+Up/Down in in-process mode or by clicking the pane in split mode, then either:\n\n* Give them additional instructions directly\n* Spawn a replacement teammate to continue the work\n\n### Lead shuts down before work is done\n\nThe lead may decide the team is finished before all tasks are actually complete. If this happens, tell it to keep going. You can also tell the lead to wait for teammates to finish before proceeding if it starts doing work instead of delegating.\n\n### Orphaned tmux sessions\n\nIf a tmux session persists after the team ends, it may not have been fully cleaned up. List sessions and kill the one created by the team:\n\n```bash  theme={null}\ntmux ls\ntmux kill-session -t <session-name>\n```\n\n## Limitations\n\nAgent teams are experimental. Current limitations to be aware of:\n\n* **No session resumption with in-process teammates**: `/resume` and `/rewind` do not restore in-process teammates. After resuming a session, the lead may attempt to message teammates that no longer exist. If this happens, tell the lead to spawn new teammates.\n* **Task status can lag**: teammates sometimes fail to mark tasks as completed, which blocks dependent tasks. If a task appears stuck, check whether the work is actually done and update the task status manually or tell the lead to nudge the teammate.\n* **Shutdown can be slow**: teammates finish their current request or tool call before shutting down, which can take time.\n* **One team per session**: a lead can only manage one team at a time. Clean up the current team before starting a new one.\n* **No nested teams**: teammates cannot spawn their own teams or teammates. Only the lead can manage the team.\n* **Lead is fixed**: the session that creates the team is the lead for its lifetime. You can't promote a teammate to lead or transfer leadership.\n* **Permissions set at spawn**: all teammates start with the lead's permission mode. You can change individual teammate modes after spawning, but you can't set per-teammate modes at spawn time.\n* **Split panes require tmux or iTerm2**: the default in-process mode works in any terminal. Split-pane mode isn't supported in VS Code's integrated terminal, Windows Terminal, or Ghostty.\n\n<Tip>\n  **`CLAUDE.md` works normally**: teammates read `CLAUDE.md` files from their working directory. Use this to provide project-specific guidance to all teammates.\n</Tip>\n\n## Next steps\n\nExplore related approaches for parallel work and delegation:\n\n* **Lightweight delegation**: [subagents](/en/sub-agents) spawn helper agents for research or verification within your session, better for tasks that don't need inter-agent coordination\n* **Manual parallel sessions**: [Git worktrees](/en/common-workflows#run-parallel-claude-code-sessions-with-git-worktrees) let you run multiple Claude Code sessions yourself without automated team coordination\n* **Compare approaches**: see the [subagent vs agent team](/en/features-overview#compare-similar-features) comparison for a side-by-side breakdown\n"}]},"uuid":"7d8eb281-f44e-440d-ab93-68f17320f8eb","timestamp":"2026-02-16T21:52:59.881Z","sourceToolAssistantUUID":"dfec715e-486a-4e31-b737-9bde5792e3b3"}
{"parentUuid":"a57dfa49-e415-4378-b27e-e4c4908aa1db","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FB7eV9jBeZ9qPNJebPdYRH","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# Automate workflows with hooks\n\n> Run shell commands automatically when Claude Code edits files, finishes tasks, or needs input. Format code, send notifications, validate commands, and enforce project rules.\n\nHooks are user-defined shell commands that execute at specific points in Claude Code's lifecycle. They provide deterministic control over Claude Code's behavior, ensuring certain actions always happen rather than relying on the LLM to choose to run them. Use hooks to enforce project rules, automate repetitive tasks, and integrate Claude Code with your existing tools.\n\nFor decisions that require judgment rather than deterministic rules, you can also use [prompt-based hooks](#prompt-based-hooks) or [agent-based hooks](#agent-based-hooks) that use a Claude model to evaluate conditions.\n\nFor other ways to extend Claude Code, see [skills](/en/skills) for giving Claude additional instructions and executable commands, [subagents](/en/sub-agents) for running tasks in isolated contexts, and [plugins](/en/plugins) for packaging extensions to share across projects.\n\n<Tip>\n  This guide covers common use cases and how to get started. For full event schemas, JSON input/output formats, and advanced features like async hooks and MCP tool hooks, see the [Hooks reference](/en/hooks).\n</Tip>\n\n## Set up your first hook\n\nThe fastest way to create a hook is through the `/hooks` interactive menu in Claude Code. This walkthrough creates a desktop notification hook, so you get alerted whenever Claude is waiting for your input instead of watching the terminal.\n\n<Steps>\n  <Step title=\"Open the hooks menu\">\n    Type `/hooks` in the Claude Code CLI. You'll see a list of all available hook events, plus an option to disable all hooks. Each event corresponds to a point in Claude's lifecycle where you can run custom code. Select `Notification` to create a hook that fires when Claude needs your attention.\n  </Step>\n\n  <Step title=\"Configure the matcher\">\n    The menu shows a list of matchers, which filter when the hook fires. Set the matcher to `*` to fire on all notification types. You can narrow it later by changing the matcher to a specific value like `permission_prompt` or `idle_prompt`.\n  </Step>\n\n  <Step title=\"Add your command\">\n    Select `+ Add new hook`. The menu prompts you for a shell command to run when the event fires. Hooks run any shell command you provide, so you can use your platform's built-in notification tool. Copy the command for your OS:\n\n    <Tabs>\n      <Tab title=\"macOS\">\n        Uses [`osascript`](https://ss64.com/mac/osascript.html) to trigger a native macOS notification through AppleScript:\n\n        ```\n        osascript -e 'display notification \"Claude Code needs your attention\" with title \"Claude Code\"'\n        ```\n      </Tab>\n\n      <Tab title=\"Linux\">\n        Uses `notify-send`, which is pre-installed on most Linux desktops with a notification daemon:\n\n        ```\n        notify-send 'Claude Code' 'Claude Code needs your attention'\n        ```\n      </Tab>\n\n      <Tab title=\"Windows (PowerShell)\">\n        Uses PowerShell to show a native message box through .NET's Windows Forms:\n\n        ```\n        powershell.exe -Command \"[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')\"\n        ```\n      </Tab>\n    </Tabs>\n  </Step>\n\n  <Step title=\"Choose a storage location\">\n    The menu asks where to save the hook configuration. Select `User settings` to store it in `~/.claude/settings.json`, which applies the hook to all your projects. You could also choose `Project settings` to scope it to the current project. See [Configure hook location](#configure-hook-location) for all available scopes.\n  </Step>\n\n  <Step title=\"Test the hook\">\n    Press `Esc` to return to the CLI. Ask Claude to do something that requires permission, then switch away from the terminal. You should receive a desktop notification.\n  </Step>\n</Steps>\n\n## What you can automate\n\nHooks let you run code at key points in Claude Code's lifecycle: format files after edits, block commands before they execute, send notifications when Claude needs input, inject context at session start, and more. For the full list of hook events, see the [Hooks reference](/en/hooks#hook-lifecycle).\n\nEach example includes a ready-to-use configuration block that you add to a [settings file](#configure-hook-location). The most common patterns:\n\n* [Get notified when Claude needs input](#get-notified-when-claude-needs-input)\n* [Auto-format code after edits](#auto-format-code-after-edits)\n* [Block edits to protected files](#block-edits-to-protected-files)\n* [Re-inject context after compaction](#re-inject-context-after-compaction)\n\n### Get notified when Claude needs input\n\nGet a desktop notification whenever Claude finishes working and needs your input, so you can switch to other tasks without checking the terminal.\n\nThis hook uses the `Notification` event, which fires when Claude is waiting for input or permission. Each tab below uses the platform's native notification command. Add this to `~/.claude/settings.json`, or use the [interactive walkthrough](#set-up-your-first-hook) above to configure it with `/hooks`:\n\n<Tabs>\n  <Tab title=\"macOS\">\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"Notification\": [\n          {\n            \"matcher\": \"\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"osascript -e 'display notification \\\"Claude Code needs your attention\\\" with title \\\"Claude Code\\\"'\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Linux\">\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"Notification\": [\n          {\n            \"matcher\": \"\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"notify-send 'Claude Code' 'Claude Code needs your attention'\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Windows (PowerShell)\">\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"Notification\": [\n          {\n            \"matcher\": \"\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"powershell.exe -Command \\\"[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms'); [System.Windows.Forms.MessageBox]::Show('Claude Code needs your attention', 'Claude Code')\\\"\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n</Tabs>\n\n### Auto-format code after edits\n\nAutomatically run [Prettier](https://prettier.io/) on every file Claude edits, so formatting stays consistent without manual intervention.\n\nThis hook uses the `PostToolUse` event with an `Edit|Write` matcher, so it runs only after file-editing tools. The command extracts the edited file path with [`jq`](https://jqlang.github.io/jq/) and passes it to Prettier. Add this to `.claude/settings.json` in your project root:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"jq -r '.tool_input.file_path' | xargs npx prettier --write\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n<Note>\n  The Bash examples on this page use `jq` for JSON parsing. Install it with `brew install jq` (macOS), `apt-get install jq` (Debian/Ubuntu), or see [`jq` downloads](https://jqlang.github.io/jq/download/).\n</Note>\n\n### Block edits to protected files\n\nPrevent Claude from modifying sensitive files like `.env`, `package-lock.json`, or anything in `.git/`. Claude receives feedback explaining why the edit was blocked, so it can adjust its approach.\n\nThis example uses a separate script file that the hook calls. The script checks the target file path against a list of protected patterns and exits with code 2 to block the edit.\n\n<Steps>\n  <Step title=\"Create the hook script\">\n    Save this to `.claude/hooks/protect-files.sh`:\n\n    ```bash  theme={null}\n    #!/bin/bash\n    # protect-files.sh\n\n    INPUT=$(cat)\n    FILE_PATH=$(echo \"$INPUT\" | jq -r '.tool_input.file_path // empty')\n\n    PROTECTED_PATTERNS=(\".env\" \"package-lock.json\" \".git/\")\n\n    for pattern in \"${PROTECTED_PATTERNS[@]}\"; do\n      if [[ \"$FILE_PATH\" == *\"$pattern\"* ]]; then\n        echo \"Blocked: $FILE_PATH matches protected pattern '$pattern'\" >&2\n        exit 2\n      fi\n    done\n\n    exit 0\n    ```\n  </Step>\n\n  <Step title=\"Make the script executable (macOS/Linux)\">\n    Hook scripts must be executable for Claude Code to run them:\n\n    ```bash  theme={null}\n    chmod +x .claude/hooks/protect-files.sh\n    ```\n  </Step>\n\n  <Step title=\"Register the hook\">\n    Add a `PreToolUse` hook to `.claude/settings.json` that runs the script before any `Edit` or `Write` tool call:\n\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"PreToolUse\": [\n          {\n            \"matcher\": \"Edit|Write\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"\\\"$CLAUDE_PROJECT_DIR\\\"/.claude/hooks/protect-files.sh\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Step>\n</Steps>\n\n### Re-inject context after compaction\n\nWhen Claude's context window fills up, compaction summarizes the conversation to free space. This can lose important details. Use a `SessionStart` hook with a `compact` matcher to re-inject critical context after every compaction.\n\nAny text your command writes to stdout is added to Claude's context. This example reminds Claude of project conventions and recent work. Add this to `.claude/settings.json` in your project root:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"compact\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo 'Reminder: use Bun, not npm. Run bun test before committing. Current sprint: auth refactor.'\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nYou can replace the `echo` with any command that produces dynamic output, like `git log --oneline -5` to show recent commits. For injecting context on every session start, consider using [CLAUDE.md](/en/memory) instead. For environment variables, see [`CLAUDE_ENV_FILE`](/en/hooks#persist-environment-variables) in the reference.\n\n## How hooks work\n\nHook events fire at specific lifecycle points in Claude Code. When an event fires, all matching hooks run in parallel, and identical hook commands are automatically deduplicated. The table below shows each event and when it triggers:\n\n| Event                | When it fires                                                      |\n| :------------------- | :----------------------------------------------------------------- |\n| `SessionStart`       | When a session begins or resumes                                   |\n| `UserPromptSubmit`   | When you submit a prompt, before Claude processes it               |\n| `PreToolUse`         | Before a tool call executes. Can block it                          |\n| `PermissionRequest`  | When a permission dialog appears                                   |\n| `PostToolUse`        | After a tool call succeeds                                         |\n| `PostToolUseFailure` | After a tool call fails                                            |\n| `Notification`       | When Claude Code sends a notification                              |\n| `SubagentStart`      | When a subagent is spawned                                         |\n| `SubagentStop`       | When a subagent finishes                                           |\n| `Stop`               | When Claude finishes responding                                    |\n| `TeammateIdle`       | When an [agent team](/en/agent-teams) teammate is about to go idle |\n| `TaskCompleted`      | When a task is being marked as completed                           |\n| `PreCompact`         | Before context compaction                                          |\n| `SessionEnd`         | When a session terminates                                          |\n\nEach hook has a `type` that determines how it runs. Most hooks use `\"type\": \"command\"`, which runs a shell command. Two other options use a Claude model to make decisions: `\"type\": \"prompt\"` for single-turn evaluation and `\"type\": \"agent\"` for multi-turn verification with tool access. See [Prompt-based hooks](#prompt-based-hooks) and [Agent-based hooks](#agent-based-hooks) for details.\n\n### Read input and return output\n\nHooks communicate with Claude Code through stdin, stdout, stderr, and exit codes. When an event fires, Claude Code passes event-specific data as JSON to your script's stdin. Your script reads that data, does its work, and tells Claude Code what to do next via the exit code.\n\n#### Hook input\n\nEvery event includes common fields like `session_id` and `cwd`, but each event type adds different data. For example, when Claude runs a Bash command, a `PreToolUse` hook receives something like this on stdin:\n\n```json  theme={null}\n{\n  \"session_id\": \"abc123\",          // unique ID for this session\n  \"cwd\": \"/Users/sarah/myproject\", // working directory when the event fired\n  \"hook_event_name\": \"PreToolUse\", // which event triggered this hook\n  \"tool_name\": \"Bash\",             // the tool Claude is about to use\n  \"tool_input\": {                  // the arguments Claude passed to the tool\n    \"command\": \"npm test\"          // for Bash, this is the shell command\n  }\n}\n```\n\nYour script can parse that JSON and act on any of those fields. `UserPromptSubmit` hooks get the `prompt` text instead, `SessionStart` hooks get the `source` (startup, resume, compact), and so on. See [Common input fields](/en/hooks#common-input-fields) in the reference for shared fields, and each event's section for event-specific schemas.\n\n#### Hook output\n\nYour script tells Claude Code what to do next by writing to stdout or stderr and exiting with a specific code. For example, a `PreToolUse` hook that wants to block a command:\n\n```bash  theme={null}\n#!/bin/bash\nINPUT=$(cat)\nCOMMAND=$(echo \"$INPUT\" | jq -r '.tool_input.command')\n\nif echo \"$COMMAND\" | grep -q \"drop table\"; then\n  echo \"Blocked: dropping tables is not allowed\" >&2  # stderr becomes Claude's feedback\n  exit 2                                               # exit 2 = block the action\nfi\n\nexit 0  # exit 0 = let it proceed\n```\n\nThe exit code determines what happens next:\n\n* **Exit 0**: the action proceeds. For `UserPromptSubmit` and `SessionStart` hooks, anything you write to stdout is added to Claude's context.\n* **Exit 2**: the action is blocked. Write a reason to stderr, and Claude receives it as feedback so it can adjust.\n* **Any other exit code**: the action proceeds. Stderr is logged but not shown to Claude. Toggle verbose mode with `Ctrl+O` to see these messages in the transcript.\n\n#### Structured JSON output\n\nExit codes give you two options: allow or block. For more control, exit 0 and print a JSON object to stdout instead.\n\n<Note>\n  Use exit 2 to block with a stderr message, or exit 0 with JSON for structured control. Don't mix them: Claude Code ignores JSON when you exit 2.\n</Note>\n\nFor example, a `PreToolUse` hook can deny a tool call and tell Claude why, or escalate it to the user for approval:\n\n```json  theme={null}\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"PreToolUse\",\n    \"permissionDecision\": \"deny\",\n    \"permissionDecisionReason\": \"Use rg instead of grep for better performance\"\n  }\n}\n```\n\nClaude Code reads `permissionDecision` and cancels the tool call, then feeds `permissionDecisionReason` back to Claude as feedback. These three options are specific to `PreToolUse`:\n\n* `\"allow\"`: proceed without showing a permission prompt\n* `\"deny\"`: cancel the tool call and send the reason to Claude\n* `\"ask\"`: show the permission prompt to the user as normal\n\nOther events use different decision patterns. For example, `PostToolUse` and `Stop` hooks use a top-level `decision: \"block\"` field, while `PermissionRequest` uses `hookSpecificOutput.decision.behavior`. See the [summary table](/en/hooks#decision-control) in the reference for a full breakdown by event.\n\nFor `UserPromptSubmit` hooks, use `additionalContext` instead to inject text into Claude's context. Prompt-based hooks (`type: \"prompt\"`) handle output differently: see [Prompt-based hooks](#prompt-based-hooks).\n\n### Filter hooks with matchers\n\nWithout a matcher, a hook fires on every occurrence of its event. Matchers let you narrow that down. For example, if you want to run a formatter only after file edits (not after every tool call), add a matcher to your `PostToolUse` hook:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"hooks\": [\n          { \"type\": \"command\", \"command\": \"prettier --write ...\" }\n        ]\n      }\n    ]\n  }\n}\n```\n\nThe `\"Edit|Write\"` matcher is a regex pattern that matches the tool name. The hook only fires when Claude uses the `Edit` or `Write` tool, not when it uses `Bash`, `Read`, or any other tool.\n\nEach event type matches on a specific field. Matchers support exact strings and regex patterns:\n\n| Event                                                                  | What the matcher filters  | Example matcher values                                                         |\n| :--------------------------------------------------------------------- | :------------------------ | :----------------------------------------------------------------------------- |\n| `PreToolUse`, `PostToolUse`, `PostToolUseFailure`, `PermissionRequest` | tool name                 | `Bash`, `Edit\\|Write`, `mcp__.*`                                               |\n| `SessionStart`                                                         | how the session started   | `startup`, `resume`, `clear`, `compact`                                        |\n| `SessionEnd`                                                           | why the session ended     | `clear`, `logout`, `prompt_input_exit`, `bypass_permissions_disabled`, `other` |\n| `Notification`                                                         | notification type         | `permission_prompt`, `idle_prompt`, `auth_success`, `elicitation_dialog`       |\n| `SubagentStart`                                                        | agent type                | `Bash`, `Explore`, `Plan`, or custom agent names                               |\n| `PreCompact`                                                           | what triggered compaction | `manual`, `auto`                                                               |\n| `UserPromptSubmit`, `Stop`, `TeammateIdle`, `TaskCompleted`            | no matcher support        | always fires on every occurrence                                               |\n| `SubagentStop`                                                         | agent type                | same values as `SubagentStart`                                                 |\n\nA few more examples showing matchers on different event types:\n\n<Tabs>\n  <Tab title=\"Log every Bash command\">\n    Match only `Bash` tool calls and log each command to a file. The `PostToolUse` event fires after the command completes, so `tool_input.command` contains what ran. The hook receives the event data as JSON on stdin, and `jq -r '.tool_input.command'` extracts just the command string, which `>>` appends to the log file:\n\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"PostToolUse\": [\n          {\n            \"matcher\": \"Bash\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"jq -r '.tool_input.command' >> ~/.claude/command-log.txt\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Match MCP tools\">\n    MCP tools use a different naming convention than built-in tools: `mcp__<server>__<tool>`, where `<server>` is the MCP server name and `<tool>` is the tool it provides. For example, `mcp__github__search_repositories` or `mcp__filesystem__read_file`. Use a regex matcher to target all tools from a specific server, or match across servers with a pattern like `mcp__.*__write.*`. See [Match MCP tools](/en/hooks#match-mcp-tools) in the reference for the full list of examples.\n\n    The command below extracts the tool name from the hook's JSON input with `jq` and writes it to stderr, where it shows up in verbose mode (`Ctrl+O`):\n\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"PreToolUse\": [\n          {\n            \"matcher\": \"mcp__github__.*\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"echo \\\"GitHub tool called: $(jq -r '.tool_name')\\\" >&2\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Clean up on session end\">\n    The `SessionEnd` event supports matchers on the reason the session ended. This hook only fires on `clear` (when you run `/clear`), not on normal exits:\n\n    ```json  theme={null}\n    {\n      \"hooks\": {\n        \"SessionEnd\": [\n          {\n            \"matcher\": \"clear\",\n            \"hooks\": [\n              {\n                \"type\": \"command\",\n                \"command\": \"rm -f /tmp/claude-scratch-*.txt\"\n              }\n            ]\n          }\n        ]\n      }\n    }\n    ```\n  </Tab>\n</Tabs>\n\nFor full matcher syntax, see the [Hooks reference](/en/hooks#configuration).\n\n### Configure hook location\n\nWhere you add a hook determines its scope:\n\n| Location                                                   | Scope                              | Shareable                          |\n| :--------------------------------------------------------- | :--------------------------------- | :--------------------------------- |\n| `~/.claude/settings.json`                                  | All your projects                  | No, local to your machine          |\n| `.claude/settings.json`                                    | Single project                     | Yes, can be committed to the repo  |\n| `.claude/settings.local.json`                              | Single project                     | No, gitignored                     |\n| Managed policy settings                                    | Organization-wide                  | Yes, admin-controlled              |\n| [Plugin](/en/plugins) `hooks/hooks.json`                   | When plugin is enabled             | Yes, bundled with the plugin       |\n| [Skill](/en/skills) or [agent](/en/sub-agents) frontmatter | While the skill or agent is active | Yes, defined in the component file |\n\nYou can also use the [`/hooks` menu](/en/hooks#the-hooks-menu) in Claude Code to add, delete, and view hooks interactively. To disable all hooks at once, use the toggle at the bottom of the `/hooks` menu or set `\"disableAllHooks\": true` in your settings file.\n\nHooks added through the `/hooks` menu take effect immediately. If you edit settings files directly while Claude Code is running, the changes won't take effect until you review them in the `/hooks` menu or restart your session.\n\n## Prompt-based hooks\n\nFor decisions that require judgment rather than deterministic rules, use `type: \"prompt\"` hooks. Instead of running a shell command, Claude Code sends your prompt and the hook's input data to a Claude model (Haiku by default) to make the decision. You can specify a different model with the `model` field if you need more capability.\n\nThe model's only job is to return a yes/no decision as JSON:\n\n* `\"ok\": true`: the action proceeds\n* `\"ok\": false`: the action is blocked. The model's `\"reason\"` is fed back to Claude so it can adjust.\n\nThis example uses a `Stop` hook to ask the model whether all requested tasks are complete. If the model returns `\"ok\": false`, Claude keeps working and uses the `reason` as its next instruction:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"prompt\",\n            \"prompt\": \"Check if all tasks are complete. If not, respond with {\\\"ok\\\": false, \\\"reason\\\": \\\"what remains to be done\\\"}.\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nFor full configuration options, see [Prompt-based hooks](/en/hooks#prompt-based-hooks) in the reference.\n\n## Agent-based hooks\n\nWhen verification requires inspecting files or running commands, use `type: \"agent\"` hooks. Unlike prompt hooks which make a single LLM call, agent hooks spawn a subagent that can read files, search code, and use other tools to verify conditions before returning a decision.\n\nAgent hooks use the same `\"ok\"` / `\"reason\"` response format as prompt hooks, but with a longer default timeout of 60 seconds and up to 50 tool-use turns.\n\nThis example verifies that tests pass before allowing Claude to stop:\n\n```json  theme={null}\n{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"agent\",\n            \"prompt\": \"Verify that all unit tests pass. Run the test suite and check the results. $ARGUMENTS\",\n            \"timeout\": 120\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nUse prompt hooks when the hook input data alone is enough to make a decision. Use agent hooks when you need to verify something against the actual state of the codebase.\n\nFor full configuration options, see [Agent-based hooks](/en/hooks#agent-based-hooks) in the reference.\n\n## Limitations and troubleshooting\n\n### Limitations\n\n* Hooks communicate through stdout, stderr, and exit codes only. They cannot trigger slash commands or tool calls directly.\n* Hook timeout is 10 minutes by default, configurable per hook with the `timeout` field (in seconds).\n* `PostToolUse` hooks cannot undo actions since the tool has already executed.\n* `PermissionRequest` hooks do not fire in [non-interactive mode](/en/headless) (`-p`). Use `PreToolUse` hooks for automated permission decisions.\n* `Stop` hooks fire whenever Claude finishes responding, not only at task completion. They do not fire on user interrupts.\n\n### Hook not firing\n\nThe hook is configured but never executes.\n\n* Run `/hooks` and confirm the hook appears under the correct event\n* Check that the matcher pattern matches the tool name exactly (matchers are case-sensitive)\n* Verify you're triggering the right event type (e.g., `PreToolUse` fires before tool execution, `PostToolUse` fires after)\n* If using `PermissionRequest` hooks in non-interactive mode (`-p`), switch to `PreToolUse` instead\n\n### Hook error in output\n\nYou see a message like \"PreToolUse hook error: ...\" in the transcript.\n\n* Your script exited with a non-zero code unexpectedly. Test it manually by piping sample JSON:\n  ```bash  theme={null}\n  echo '{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"ls\"}}' | ./my-hook.sh\n  echo $?  # Check the exit code\n  ```\n* If you see \"command not found\", use absolute paths or `$CLAUDE_PROJECT_DIR` to reference scripts\n* If you see \"jq: command not found\", install `jq` or use Python/Node.js for JSON parsing\n* If the script isn't running at all, make it executable: `chmod +x ./my-hook.sh`\n\n### `/hooks` shows no hooks configured\n\nYou edited a settings file but the hooks don't appear in the menu.\n\n* Restart your session or open `/hooks` to reload. Hooks added through the `/hooks` menu take effect immediately, but manual file edits require a reload.\n* Verify your JSON is valid (trailing commas and comments are not allowed)\n* Confirm the settings file is in the correct location: `.claude/settings.json` for project hooks, `~/.claude/settings.json` for global hooks\n\n### Stop hook runs forever\n\nClaude keeps working in an infinite loop instead of stopping.\n\nYour Stop hook script needs to check whether it already triggered a continuation. Parse the `stop_hook_active` field from the JSON input and exit early if it's `true`:\n\n```bash  theme={null}\n#!/bin/bash\nINPUT=$(cat)\nif [ \"$(echo \"$INPUT\" | jq -r '.stop_hook_active')\" = \"true\" ]; then\n  exit 0  # Allow Claude to stop\nfi\n# ... rest of your hook logic\n```\n\n### JSON validation failed\n\nClaude Code shows a JSON parsing error even though your hook script outputs valid JSON.\n\nWhen Claude Code runs a hook, it spawns a shell that sources your profile (`~/.zshrc` or `~/.bashrc`). If your profile contains unconditional `echo` statements, that output gets prepended to your hook's JSON:\n\n```\nShell ready on arm64\n{\"decision\": \"block\", \"reason\": \"Not allowed\"}\n```\n\nClaude Code tries to parse this as JSON and fails. To fix this, wrap echo statements in your shell profile so they only run in interactive shells:\n\n```bash  theme={null}\n# In ~/.zshrc or ~/.bashrc\nif [[ $- == *i* ]]; then\n  echo \"Shell ready\"\nfi\n```\n\nThe `$-` variable contains shell flags, and `i` means interactive. Hooks run in non-interactive shells, so the echo is skipped.\n\n### Debug techniques\n\nToggle verbose mode with `Ctrl+O` to see hook output in the transcript, or run `claude --debug` for full execution details including which hooks matched and their exit codes.\n\n## Learn more\n\n* [Hooks reference](/en/hooks): full event schemas, JSON output format, async hooks, and MCP tool hooks\n* [Security considerations](/en/hooks#security-considerations): review before deploying hooks in shared or production environments\n* [Bash command validator example](https://github.com/anthropics/claude-code/blob/main/examples/hooks/bash_command_validator_example.py): complete reference implementation\n"}]},"uuid":"5f456fec-ff42-44c6-9f35-6ccbb8b6d20c","timestamp":"2026-02-16T21:52:59.881Z","sourceToolAssistantUUID":"a57dfa49-e415-4378-b27e-e4c4908aa1db"}
{"parentUuid":"0f5bd84f-028d-4c47-9b94-b1dd52a3fe02","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JT6y3pdBtZSv8t3YBUSYGu","type":"tool_result","content":"> ## Documentation Index\n> Fetch the complete documentation index at: https://code.claude.com/docs/llms.txt\n> Use this file to discover all available pages before exploring further.\n\n# Best Practices for Claude Code\n\n> Tips and patterns for getting the most out of Claude Code, from configuring your environment to scaling across parallel sessions.\n\nClaude Code is an agentic coding environment. Unlike a chatbot that answers questions and waits, Claude Code can read your files, run commands, make changes, and autonomously work through problems while you watch, redirect, or step away entirely.\n\nThis changes how you work. Instead of writing code yourself and asking Claude to review it, you describe what you want and Claude figures out how to build it. Claude explores, plans, and implements.\n\nBut this autonomy still comes with a learning curve. Claude works within certain constraints you need to understand.\n\nThis guide covers patterns that have proven effective across Anthropic's internal teams and for engineers using Claude Code across various codebases, languages, and environments. For how the agentic loop works under the hood, see [How Claude Code works](/en/how-claude-code-works).\n\n***\n\nMost best practices are based on one constraint: Claude's context window fills up fast, and performance degrades as it fills.\n\nClaude's context window holds your entire conversation, including every message, every file Claude reads, and every command output. However, this can fill up fast. A single debugging session or codebase exploration might generate and consume tens of thousands of tokens.\n\nThis matters since LLM performance degrades as context fills. When the context window is getting full, Claude may start \"forgetting\" earlier instructions or making more mistakes. The context window is the most important resource to manage. Track context usage continuously with a [custom status line](/en/statusline), and see [Reduce token usage](/en/costs#reduce-token-usage) for strategies on reducing token usage.\n\n***\n\n## Give Claude a way to verify its work\n\n<Tip>\n  Include tests, screenshots, or expected outputs so Claude can check itself. This is the single highest-leverage thing you can do.\n</Tip>\n\nClaude performs dramatically better when it can verify its own work, like run tests, compare screenshots, and validate outputs.\n\nWithout clear success criteria, it might produce something that looks right but actually doesn't work. You become the only feedback loop, and every mistake requires your attention.\n\n| Strategy                              | Before                                                  | After                                                                                                                                                                                                   |\n| ------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Provide verification criteria**     | *\"implement a function that validates email addresses\"* | *\"write a validateEmail function. example test cases: [user@example.com](mailto:user@example.com) is true, invalid is false, [user@.com](mailto:user@.com) is false. run the tests after implementing\"* |\n| **Verify UI changes visually**        | *\"make the dashboard look better\"*                      | *\"\\[paste screenshot] implement this design. take a screenshot of the result and compare it to the original. list differences and fix them\"*                                                            |\n| **Address root causes, not symptoms** | *\"the build is failing\"*                                | *\"the build fails with this error: \\[paste error]. fix it and verify the build succeeds. address the root cause, don't suppress the error\"*                                                             |\n\nUI changes can be verified using the [Claude in Chrome extension](/en/chrome). It opens new tabs in your browser, tests the UI, and iterates until the code works.\n\nYour verification can also be a test suite, a linter, or a Bash command that checks output. Invest in making your verification rock-solid.\n\n***\n\n## Explore first, then plan, then code\n\n<Tip>\n  Separate research and planning from implementation to avoid solving the wrong problem.\n</Tip>\n\nLetting Claude jump straight to coding can produce code that solves the wrong problem. Use [Plan Mode](/en/common-workflows#use-plan-mode-for-safe-code-analysis) to separate exploration from execution.\n\nThe recommended workflow has four phases:\n\n<Steps>\n  <Step title=\"Explore\">\n    Enter Plan Mode. Claude reads files and answers questions without making changes.\n\n    ```txt claude (Plan Mode) theme={null}\n    read /src/auth and understand how we handle sessions and login.\n    also look at how we manage environment variables for secrets.\n    ```\n  </Step>\n\n  <Step title=\"Plan\">\n    Ask Claude to create a detailed implementation plan.\n\n    ```txt claude (Plan Mode) theme={null}\n    I want to add Google OAuth. What files need to change?\n    What's the session flow? Create a plan.\n    ```\n\n    Press `Ctrl+G` to open the plan in your text editor for direct editing before Claude proceeds.\n  </Step>\n\n  <Step title=\"Implement\">\n    Switch back to Normal Mode and let Claude code, verifying against its plan.\n\n    ```txt claude (Normal Mode) theme={null}\n    implement the OAuth flow from your plan. write tests for the\n    callback handler, run the test suite and fix any failures.\n    ```\n  </Step>\n\n  <Step title=\"Commit\">\n    Ask Claude to commit with a descriptive message and create a PR.\n\n    ```txt claude (Normal Mode) theme={null}\n    commit with a descriptive message and open a PR\n    ```\n  </Step>\n</Steps>\n\n<Callout>\n  Plan Mode is useful, but also adds overhead.\n\n  For tasks where the scope is clear and the fix is small (like fixing a typo, adding a log line, or renaming a variable) ask Claude to do it directly.\n\n  Planning is most useful when you're uncertain about the approach, when the change modifies multiple files, or when you're unfamiliar with the code being modified. If you could describe the diff in one sentence, skip the plan.\n</Callout>\n\n***\n\n## Provide specific context in your prompts\n\n<Tip>\n  The more precise your instructions, the fewer corrections you'll need.\n</Tip>\n\nClaude can infer intent, but it can't read your mind. Reference specific files, mention constraints, and point to example patterns.\n\n| Strategy                                                                                         | Before                                               | After                                                                                                                                                                                                                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------ | ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Scope the task.** Specify which file, what scenario, and testing preferences.                  | *\"add tests for foo.py\"*                             | *\"write a test for foo.py covering the edge case where the user is logged out. avoid mocks.\"*                                                                                                                                                                                                                                                                    |\n| **Point to sources.** Direct Claude to the source that can answer a question.                    | *\"why does ExecutionFactory have such a weird api?\"* | *\"look through ExecutionFactory's git history and summarize how its api came to be\"*                                                                                                                                                                                                                                                                             |\n| **Reference existing patterns.** Point Claude to patterns in your codebase.                      | *\"add a calendar widget\"*                            | *\"look at how existing widgets are implemented on the home page to understand the patterns. HotDogWidget.php is a good example. follow the pattern to implement a new calendar widget that lets the user select a month and paginate forwards/backwards to pick a year. build from scratch without libraries other than the ones already used in the codebase.\"* |\n| **Describe the symptom.** Provide the symptom, the likely location, and what \"fixed\" looks like. | *\"fix the login bug\"*                                | *\"users report that login fails after session timeout. check the auth flow in src/auth/, especially token refresh. write a failing test that reproduces the issue, then fix it\"*                                                                                                                                                                                 |\n\nVague prompts can be useful when you're exploring and can afford to course-correct. A prompt like `\"what would you improve in this file?\"` can surface things you wouldn't have thought to ask about.\n\n### Provide rich content\n\n<Tip>\n  Use `@` to reference files, paste screenshots/images, or pipe data directly.\n</Tip>\n\nYou can provide rich data to Claude in several ways:\n\n* **Reference files with `@`** instead of describing where code lives. Claude reads the file before responding.\n* **Paste images directly**. Copy/paste or drag and drop images into the prompt.\n* **Give URLs** for documentation and API references. Use `/permissions` to allowlist frequently-used domains.\n* **Pipe in data** by running `cat error.log | claude` to send file contents directly.\n* **Let Claude fetch what it needs**. Tell Claude to pull context itself using Bash commands, MCP tools, or by reading files.\n\n***\n\n## Configure your environment\n\nA few setup steps make Claude Code significantly more effective across all your sessions. For a full overview of extension features and when to use each one, see [Extend Claude Code](/en/features-overview).\n\n### Write an effective CLAUDE.md\n\n<Tip>\n  Run `/init` to generate a starter CLAUDE.md file based on your current project structure, then refine over time.\n</Tip>\n\nCLAUDE.md is a special file that Claude reads at the start of every conversation. Include Bash commands, code style, and workflow rules. This gives Claude persistent context **it can't infer from code alone**.\n\nThe `/init` command analyzes your codebase to detect build systems, test frameworks, and code patterns, giving you a solid foundation to refine.\n\nThere's no required format for CLAUDE.md files, but keep it short and human-readable. For example:\n\n```markdown CLAUDE.md theme={null}\n# Code style\n- Use ES modules (import/export) syntax, not CommonJS (require)\n- Destructure imports when possible (eg. import { foo } from 'bar')\n\n# Workflow\n- Be sure to typecheck when you're done making a series of code changes\n- Prefer running single tests, and not the whole test suite, for performance\n```\n\nCLAUDE.md is loaded every session, so only include things that apply broadly. For domain knowledge or workflows that are only relevant sometimes, use [skills](/en/skills) instead. Claude loads them on demand without bloating every conversation.\n\nKeep it concise. For each line, ask: *\"Would removing this cause Claude to make mistakes?\"* If not, cut it. Bloated CLAUDE.md files cause Claude to ignore your actual instructions!\n\n|  Include                                            |  Exclude                                          |\n| ---------------------------------------------------- | -------------------------------------------------- |\n| Bash commands Claude can't guess                     | Anything Claude can figure out by reading code     |\n| Code style rules that differ from defaults           | Standard language conventions Claude already knows |\n| Testing instructions and preferred test runners      | Detailed API documentation (link to docs instead)  |\n| Repository etiquette (branch naming, PR conventions) | Information that changes frequently                |\n| Architectural decisions specific to your project     | Long explanations or tutorials                     |\n| Developer environment quirks (required env vars)     | File-by-file descriptions of the codebase          |\n| Common gotchas or non-obvious behaviors              | Self-evident practices like \"write clean code\"     |\n\nIf Claude keeps doing something you don't want despite having a rule against it, the file is probably too long and the rule is getting lost. If Claude asks you questions that are answered in CLAUDE.md, the phrasing might be ambiguous. Treat CLAUDE.md like code: review it when things go wrong, prune it regularly, and test changes by observing whether Claude's behavior actually shifts.\n\nYou can tune instructions by adding emphasis (e.g., \"IMPORTANT\" or \"YOU MUST\") to improve adherence. Check CLAUDE.md into git so your team can contribute. The file compounds in value over time.\n\nCLAUDE.md files can import additional files using `@path/to/import` syntax:\n\n```markdown CLAUDE.md theme={null}\nSee @README.md for project overview and @package.json for available npm commands.\n\n# Additional Instructions\n- Git workflow: @docs/git-instructions.md\n- Personal overrides: @~/.claude/my-project-instructions.md\n```\n\nYou can place CLAUDE.md files in several locations:\n\n* **Home folder (`~/.claude/CLAUDE.md`)**: Applies to all Claude sessions\n* **Project root (`./CLAUDE.md`)**: Check into git to share with your team, or name it `CLAUDE.local.md` and `.gitignore` it\n* **Parent directories**: Useful for monorepos where both `root/CLAUDE.md` and `root/foo/CLAUDE.md` are pulled in automatically\n* **Child directories**: Claude pulls in child CLAUDE.md files on demand when working with files in those directories\n\n### Configure permissions\n\n<Tip>\n  Use `/permissions` to allowlist safe commands or `/sandbox` for OS-level isolation. This reduces interruptions while keeping you in control.\n</Tip>\n\nBy default, Claude Code requests permission for actions that might modify your system: file writes, Bash commands, MCP tools, etc. This is safe but tedious. After the tenth approval you're not really reviewing anymore, you're just clicking through. There are two ways to reduce these interruptions:\n\n* **Permission allowlists**: Permit specific tools you know are safe (like `npm run lint` or `git commit`)\n* **Sandboxing**: Enable OS-level isolation that restricts filesystem and network access, allowing Claude to work more freely within defined boundaries\n\nAlternatively, use `--dangerously-skip-permissions` to bypass all permission checks for contained workflows like fixing lint errors or generating boilerplate.\n\n<Warning>\n  Letting Claude run arbitrary commands can result in data loss, system corruption, or data exfiltration via prompt injection. Only use `--dangerously-skip-permissions` in a sandbox without internet access.\n</Warning>\n\nRead more about [configuring permissions](/en/settings) and [enabling sandboxing](/en/sandboxing#sandboxing).\n\n### Use CLI tools\n\n<Tip>\n  Tell Claude Code to use CLI tools like `gh`, `aws`, `gcloud`, and `sentry-cli` when interacting with external services.\n</Tip>\n\nCLI tools are the most context-efficient way to interact with external services. If you use GitHub, install the `gh` CLI. Claude knows how to use it for creating issues, opening pull requests, and reading comments. Without `gh`, Claude can still use the GitHub API, but unauthenticated requests often hit rate limits.\n\nClaude is also effective at learning CLI tools it doesn't already know. Try prompts like `Use 'foo-cli-tool --help' to learn about foo tool, then use it to solve A, B, C.`\n\n### Connect MCP servers\n\n<Tip>\n  Run `claude mcp add` to connect external tools like Notion, Figma, or your database.\n</Tip>\n\nWith [MCP servers](/en/mcp), you can ask Claude to implement features from issue trackers, query databases, analyze monitoring data, integrate designs from Figma, and automate workflows.\n\n### Set up hooks\n\n<Tip>\n  Use hooks for actions that must happen every time with zero exceptions.\n</Tip>\n\n[Hooks](/en/hooks-guide) run scripts automatically at specific points in Claude's workflow. Unlike CLAUDE.md instructions which are advisory, hooks are deterministic and guarantee the action happens.\n\nClaude can write hooks for you. Try prompts like *\"Write a hook that runs eslint after every file edit\"* or *\"Write a hook that blocks writes to the migrations folder.\"* Run `/hooks` for interactive configuration, or edit `.claude/settings.json` directly.\n\n### Create skills\n\n<Tip>\n  Create `SKILL.md` files in `.claude/skills/` to give Claude domain knowledge and reusable workflows.\n</Tip>\n\n[Skills](/en/skills) extend Claude's knowledge with information specific to your project, team, or domain. Claude applies them automatically when relevant, or you can invoke them directly with `/skill-name`.\n\nCreate a skill by adding a directory with a `SKILL.md` to `.claude/skills/`:\n\n```markdown .claude/skills/api-conventions/SKILL.md theme={null}\n---\nname: api-conventions\ndescription: REST API design conventions for our services\n---\n# API Conventions\n- Use kebab-case for URL paths\n- Use camelCase for JSON properties\n- Always include pagination for list endpoints\n- Version APIs in the URL path (/v1/, /v2/)\n```\n\nSkills can also define repeatable workflows you invoke directly:\n\n```markdown .claude/skills/fix-issue/SKILL.md theme={null}\n---\nname: fix-issue\ndescription: Fix a GitHub issue\ndisable-model-invocation: true\n---\nAnalyze and fix the GitHub issue: $ARGUMENTS.\n\n1. Use `gh issue view` to get the issue details\n2. Understand the problem described in the issue\n3. Search the codebase for relevant files\n4. Implement the necessary changes to fix the issue\n5. Write and run tests to verify the fix\n6. Ensure code passes linting and type checking\n7. Create a descriptive commit message\n8. Push and create a PR\n```\n\nRun `/fix-issue 1234` to invoke it. Use `disable-model-invocation: true` for workflows with side effects that you want to trigger manually.\n\n### Create custom subagents\n\n<Tip>\n  Define specialized assistants in `.claude/agents/` that Claude can delegate to for isolated tasks.\n</Tip>\n\n[Subagents](/en/sub-agents) run in their own context with their own set of allowed tools. They're useful for tasks that read many files or need specialized focus without cluttering your main conversation.\n\n```markdown .claude/agents/security-reviewer.md theme={null}\n---\nname: security-reviewer\ndescription: Reviews code for security vulnerabilities\ntools: Read, Grep, Glob, Bash\nmodel: opus\n---\nYou are a senior security engineer. Review code for:\n- Injection vulnerabilities (SQL, XSS, command injection)\n- Authentication and authorization flaws\n- Secrets or credentials in code\n- Insecure data handling\n\nProvide specific line references and suggested fixes.\n```\n\nTell Claude to use subagents explicitly: *\"Use a subagent to review this code for security issues.\"*\n\n### Install plugins\n\n<Tip>\n  Run `/plugin` to browse the marketplace. Plugins add skills, tools, and integrations without configuration.\n</Tip>\n\n[Plugins](/en/plugins) bundle skills, hooks, subagents, and MCP servers into a single installable unit from the community and Anthropic. If you work with a typed language, install a [code intelligence plugin](/en/discover-plugins#code-intelligence) to give Claude precise symbol navigation and automatic error detection after edits.\n\nFor guidance on choosing between skills, subagents, hooks, and MCP, see [Extend Claude Code](/en/features-overview#match-features-to-your-goal).\n\n***\n\n## Communicate effectively\n\nThe way you communicate with Claude Code significantly impacts the quality of results.\n\n### Ask codebase questions\n\n<Tip>\n  Ask Claude questions you'd ask a senior engineer.\n</Tip>\n\nWhen onboarding to a new codebase, use Claude Code for learning and exploration. You can ask Claude the same sorts of questions you would ask another engineer:\n\n* How does logging work?\n* How do I make a new API endpoint?\n* What does `async move { ... }` do on line 134 of `foo.rs`?\n* What edge cases does `CustomerOnboardingFlowImpl` handle?\n* Why does this code call `foo()` instead of `bar()` on line 333?\n\nUsing Claude Code this way is an effective onboarding workflow, improving ramp-up time and reducing load on other engineers. No special prompting required: ask questions directly.\n\n### Let Claude interview you\n\n<Tip>\n  For larger features, have Claude interview you first. Start with a minimal prompt and ask Claude to interview you using the `AskUserQuestion` tool.\n</Tip>\n\nClaude asks about things you might not have considered yet, including technical implementation, UI/UX, edge cases, and tradeoffs.\n\n```\nI want to build [brief description]. Interview me in detail using the AskUserQuestion tool.\n\nAsk about technical implementation, UI/UX, edge cases, concerns, and tradeoffs. Don't ask obvious questions, dig into the hard parts I might not have considered.\n\nKeep interviewing until we've covered everything, then write a complete spec to SPEC.md.\n```\n\nOnce the spec is complete, start a fresh session to execute it. The new session has clean context focused entirely on implementation, and you have a written spec to reference.\n\n***\n\n## Manage your session\n\nConversations are persistent and reversible. Use this to your advantage!\n\n### Course-correct early and often\n\n<Tip>\n  Correct Claude as soon as you notice it going off track.\n</Tip>\n\nThe best results come from tight feedback loops. Though Claude occasionally solves problems perfectly on the first attempt, correcting it quickly generally produces better solutions faster.\n\n* **`Esc`**: Stop Claude mid-action with the `Esc` key. Context is preserved, so you can redirect.\n* **`Esc + Esc` or `/rewind`**: Press `Esc` twice or run `/rewind` to open the rewind menu and restore previous conversation and code state, or summarize from a selected message.\n* **`\"Undo that\"`**: Have Claude revert its changes.\n* **`/clear`**: Reset context between unrelated tasks. Long sessions with irrelevant context can reduce performance.\n\nIf you've corrected Claude more than twice on the same issue in one session, the context is cluttered with failed approaches. Run `/clear` and start fresh with a more specific prompt that incorporates what you learned. A clean session with a better prompt almost always outperforms a long session with accumulated corrections.\n\n### Manage context aggressively\n\n<Tip>\n  Run `/clear` between unrelated tasks to reset context.\n</Tip>\n\nClaude Code automatically compacts conversation history when you approach context limits, which preserves important code and decisions while freeing space.\n\nDuring long sessions, Claude's context window can fill with irrelevant conversation, file contents, and commands. This can reduce performance and sometimes distract Claude.\n\n* Use `/clear` frequently between tasks to reset the context window entirely\n* When auto compaction triggers, Claude summarizes what matters most, including code patterns, file states, and key decisions\n* For more control, run `/compact <instructions>`, like `/compact Focus on the API changes`\n* To compact only part of the conversation, use `Esc + Esc` or `/rewind`, select a message checkpoint, and choose **Summarize from here**. This condenses messages from that point forward while keeping earlier context intact.\n* Customize compaction behavior in CLAUDE.md with instructions like `\"When compacting, always preserve the full list of modified files and any test commands\"` to ensure critical context survives summarization\n\n### Use subagents for investigation\n\n<Tip>\n  Delegate research with `\"use subagents to investigate X\"`. They explore in a separate context, keeping your main conversation clean for implementation.\n</Tip>\n\nSince context is your fundamental constraint, subagents are one of the most powerful tools available. When Claude researches a codebase it reads lots of files, all of which consume your context. Subagents run in separate context windows and report back summaries:\n\n```\nUse subagents to investigate how our authentication system handles token\nrefresh, and whether we have any existing OAuth utilities I should reuse.\n```\n\nThe subagent explores the codebase, reads relevant files, and reports back with findings, all without cluttering your main conversation.\n\nYou can also use subagents for verification after Claude implements something:\n\n```\nuse a subagent to review this code for edge cases\n```\n\n### Rewind with checkpoints\n\n<Tip>\n  Every action Claude makes creates a checkpoint. You can restore conversation, code, or both to any previous checkpoint.\n</Tip>\n\nClaude automatically checkpoints before changes. Double-tap `Escape` or run `/rewind` to open the rewind menu. You can restore conversation only, restore code only, restore both, or summarize from a selected message. See [Checkpointing](/en/checkpointing) for details.\n\nInstead of carefully planning every move, you can tell Claude to try something risky. If it doesn't work, rewind and try a different approach. Checkpoints persist across sessions, so you can close your terminal and still rewind later.\n\n<Warning>\n  Checkpoints only track changes made *by Claude*, not external processes. This isn't a replacement for git.\n</Warning>\n\n### Resume conversations\n\n<Tip>\n  Run `claude --continue` to pick up where you left off, or `--resume` to choose from recent sessions.\n</Tip>\n\nClaude Code saves conversations locally. When a task spans multiple sessions (you start a feature, get interrupted, come back the next day) you don't have to re-explain the context:\n\n```bash  theme={null}\nclaude --continue    # Resume the most recent conversation\nclaude --resume      # Select from recent conversations\n```\n\nUse `/rename` to give sessions descriptive names (`\"oauth-migration\"`, `\"debugging-memory-leak\"`) so you can find them later. Treat sessions like branches. Different workstreams can have separate, persistent contexts.\n\n***\n\n## Automate and scale\n\nOnce you're effective with one Claude, multiply your output with parallel sessions, headless mode, and fan-out patterns.\n\nEverything so far assumes one human, one Claude, and one conversation. But Claude Code scales horizontally. The techniques in this section show how you can get more done.\n\n### Run headless mode\n\n<Tip>\n  Use `claude -p \"prompt\"` in CI, pre-commit hooks, or scripts. Add `--output-format stream-json` for streaming JSON output.\n</Tip>\n\nWith `claude -p \"your prompt\"`, you can run Claude headlessly, without an interactive session. Headless mode is how you integrate Claude into CI pipelines, pre-commit hooks, or any automated workflow. The output formats (plain text, JSON, streaming JSON) let you parse results programmatically.\n\n```bash  theme={null}\n# One-off queries\nclaude -p \"Explain what this project does\"\n\n# Structured output for scripts\nclaude -p \"List all API endpoints\" --output-format json\n\n# Streaming for real-time processing\nclaude -p \"Analyze this log file\" --output-format stream-json\n```\n\n### Run multiple Claude sessions\n\n<Tip>\n  Run multiple Claude sessions in parallel to speed up development, run isolated experiments, or start complex workflows.\n</Tip>\n\nThere are three main ways to run parallel sessions:\n\n* [Claude Code desktop app](/en/desktop#work-in-parallel-with-sessions): Manage multiple local sessions visually. Each session gets its own isolated worktree.\n* [Claude Code on the web](/en/claude-code-on-the-web): Run on Anthropic's secure cloud infrastructure in isolated VMs.\n* [Agent teams](/en/agent-teams): Automated coordination of multiple sessions with shared tasks, messaging, and a team lead.\n\nBeyond parallelizing work, multiple sessions enable quality-focused workflows. A fresh context improves code review since Claude won't be biased toward code it just wrote.\n\nFor example, use a Writer/Reviewer pattern:\n\n| Session A (Writer)                                                      | Session B (Reviewer)                                                                                                                                                     |\n| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `Implement a rate limiter for our API endpoints`                        |                                                                                                                                                                          |\n|                                                                         | `Review the rate limiter implementation in @src/middleware/rateLimiter.ts. Look for edge cases, race conditions, and consistency with our existing middleware patterns.` |\n| `Here's the review feedback: [Session B output]. Address these issues.` |                                                                                                                                                                          |\n\nYou can do something similar with tests: have one Claude write tests, then another write code to pass them.\n\n### Fan out across files\n\n<Tip>\n  Loop through tasks calling `claude -p` for each. Use `--allowedTools` to scope permissions for batch operations.\n</Tip>\n\nFor large migrations or analyses, you can distribute work across many parallel Claude invocations:\n\n<Steps>\n  <Step title=\"Generate a task list\">\n    Have Claude list all files that need migrating (e.g., `list all 2,000 Python files that need migrating`)\n  </Step>\n\n  <Step title=\"Write a script to loop through the list\">\n    ```bash  theme={null}\n    for file in $(cat files.txt); do\n      claude -p \"Migrate $file from React to Vue. Return OK or FAIL.\" \\\n        --allowedTools \"Edit,Bash(git commit *)\"\n    done\n    ```\n  </Step>\n\n  <Step title=\"Test on a few files, then run at scale\">\n    Refine your prompt based on what goes wrong with the first 2-3 files, then run on the full set. The `--allowedTools` flag restricts what Claude can do, which matters when you're running unattended.\n  </Step>\n</Steps>\n\nYou can also integrate Claude into existing data/processing pipelines:\n\n```bash  theme={null}\nclaude -p \"<your prompt>\" --output-format json | your_command\n```\n\nUse `--verbose` for debugging during development, and turn it off in production.\n\n### Safe Autonomous Mode\n\nUse `claude --dangerously-skip-permissions` to bypass all permission checks and let Claude work uninterrupted. This works well for workflows like fixing lint errors or generating boilerplate code.\n\n<Warning>\n  Letting Claude run arbitrary commands is risky and can result in data loss, system corruption, or data exfiltration (e.g., via prompt injection attacks). To minimize these risks, use `--dangerously-skip-permissions` in a container without internet access.\n\n  With sandboxing enabled (`/sandbox`), you get similar autonomy with better security. Sandbox defines upfront boundaries rather than bypassing all checks.\n</Warning>\n\n***\n\n## Avoid common failure patterns\n\nThese are common mistakes. Recognizing them early saves time:\n\n* **The kitchen sink session.** You start with one task, then ask Claude something unrelated, then go back to the first task. Context is full of irrelevant information.\n  > **Fix**: `/clear` between unrelated tasks.\n* **Correcting over and over.** Claude does something wrong, you correct it, it's still wrong, you correct again. Context is polluted with failed approaches.\n  > **Fix**: After two failed corrections, `/clear` and write a better initial prompt incorporating what you learned.\n* **The over-specified CLAUDE.md.** If your CLAUDE.md is too long, Claude ignores half of it because important rules get lost in the noise.\n  > **Fix**: Ruthlessly prune. If Claude already does something correctly without the instruction, delete it or convert it to a hook.\n* **The trust-then-verify gap.** Claude produces a plausible-looking implementation that doesn't handle edge cases.\n  > **Fix**: Always provide verification (tests, scripts, screenshots). If you can't verify it, don't ship it.\n* **The infinite exploration.** You ask Claude to \"investigate\" something without scoping it. Claude reads hundreds of files, filling the context.\n  > **Fix**: Scope investigations narrowly or use subagents so the exploration doesn't consume your main context.\n\n***\n\n## Develop your intuition\n\nThe patterns in this guide aren't set in stone. They're starting points that work well in general, but might not be optimal for every situation.\n\nSometimes you *should* let context accumulate because you're deep in one complex problem and the history is valuable. Sometimes you should skip planning and let Claude figure it out because the task is exploratory. Sometimes a vague prompt is exactly right because you want to see how Claude interprets the problem before constraining it.\n\nPay attention to what works. When Claude produces great output, notice what you did: the prompt structure, the context you provided, the mode you were in. When Claude struggles, ask why. Was the context too noisy? The prompt too vague? The task too big for one pass?\n\nOver time, you'll develop intuition that no guide can capture. You'll know when to be specific and when to be open-ended, when to plan and when to explore, when to clear context and when to let it accumulate.\n\n## Related resources\n\n<CardGroup cols={2}>\n  <Card title=\"How Claude Code works\" icon=\"gear\" href=\"/en/how-claude-code-works\">\n    Understand the agentic loop, tools, and context management\n  </Card>\n\n  <Card title=\"Extend Claude Code\" icon=\"puzzle-piece\" href=\"/en/features-overview\">\n    Choose between skills, hooks, MCP, subagents, and plugins\n  </Card>\n\n  <Card title=\"Common workflows\" icon=\"list-check\" href=\"/en/common-workflows\">\n    Step-by-step recipes for debugging, testing, PRs, and more\n  </Card>\n\n  <Card title=\"CLAUDE.md\" icon=\"file-lines\" href=\"/en/memory\">\n    Store project conventions and persistent context\n  </Card>\n</CardGroup>\n"}]},"uuid":"fa483da6-08d3-4b93-9c86-ac14cb3c9d2f","timestamp":"2026-02-16T21:53:00.155Z","sourceToolAssistantUUID":"0f5bd84f-028d-4c47-9b94-b1dd52a3fe02"}
{"parentUuid":"fa483da6-08d3-4b93-9c86-ac14cb3c9d2f","isSidechain":true,"userType":"external","cwd":"/Users/obliviousharmony/Code/woocommerce/woocommerce","sessionId":"23e61697-22ff-48a7-85e6-0b1960da61e3","version":"2.1.20","gitBranch":"add/62921-shared-monorepo-ts-config","agentId":"a93bb39","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SGNk9qP39fxrEtMvPng59D","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! I now have comprehensive documentation about autonomous execution in Claude Code. Let me provide you with detailed, actionable information about running Claude Code with minimal human intervention.\n\n## Autonomous Background Agents in Claude Code\n\nBased on the official documentation, here's a comprehensive guide to running Claude Code autonomously with minimal human oversight.\n\n### 1. Ways to Run Claude Code Autonomously\n\nClaude Code offers **three primary execution models** for autonomous operation:\n\n#### A. **Headless Mode (`claude -p`)**\nThe most direct autonomous approach for scripts and CI/CD:\n\n```bash\n# Basic programmatic execution\nclaude -p \"Find and fix the bug in auth.py\" --allowedTools \"Read,Edit,Bash\"\n\n# Structured output for automation\nclaude -p \"Summarize this project\" --output-format json\n\n# Streaming real-time output\nclaude -p \"Analyze this log file\" --output-format stream-json --verbose\n\n# Continue previous conversations autonomously\nsession_id=$(claude -p \"Start a review\" --output-format json | jq -r '.session_id')\nclaude -p \"Continue that review\" --resume \"$session_id\"\n```\n\n**Use headless mode when:**\n- Running from scripts, CI/CD pipelines, or cron jobs\n- You need programmatic output (JSON, structured data)\n- You want zero human interaction\n- Tasks are well-defined and don't need steering\n\n#### B. **Subagents (Foreground + Background)**\nDelegate specific tasks to specialized agents:\n\n```bash\n# Foreground subagents (blocking, with permissions passed through)\nclaude -p \"Use a subagent to run the test suite and report only failures\"\n\n# Background subagents (concurrent, non-blocking)\n# Press Ctrl+B to background a running subagent\n# Pre-approves permissions upfront, then runs independently\n```\n\n**Background subagents are ideal for:**\n- Long-running operations (tests, linting) while main agent continues\n- High-volume operations that consume context (log processing, large-scale analysis)\n- Parallel research tasks\n- Tasks that don't need real-time steering\n\n#### C. **Agent Teams** (Experimental - requires `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`)\nCoordinate multiple independent Claude sessions working in parallel:\n\n```bash\n# Request a team explicitly (minimal human overhead)\nclaude --agent team --prompt \"Create an agent team to review PR #142. \nSpawn three reviewers: security, performance, test coverage.\"\n```\n\n**Agent teams excel at:**\n- Parallel code reviews with different criteria\n- Debugging with competing hypotheses\n- Independent feature development\n- Research from multiple perspectives\n- Tasks where agents need to communicate and coordinate\n\n---\n\n### 2. Setting Up Truly Autonomous Execution\n\nTo minimize human intervention, configure these elements **before** launching autonomous agents:\n\n#### **A. Auto-approve Tools with Permission Rules**\n\n```bash\n# Pre-authorize specific commands\nclaude -p \"Run the test suite and fix failures\" \\\n  --allowedTools \"Bash,Read,Edit\"\n\n# Fine-grained control with prefix patterns\nclaude -p \"Create a commit with appropriate message\" \\\n  --allowedTools \"Bash(git diff *),Bash(git commit *),Bash(git log *)\"\n```\n\nFor long-running autonomous agents, configure in `~/.claude/settings.json`:\n\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(npm test:*)\",\n      \"Bash(npm run lint:*)\",\n      \"Edit\",\n      \"Write\"\n    ]\n  }\n}\n```\n\n#### **B. Configure CLAUDE.md with Autonomous Instructions**\n\nYour project's `CLAUDE.md` is loaded at **every session start**. Use it to guide autonomous behavior:\n\n```markdown\n# CLAUDE.md - Autonomous Agent Configuration\n\n## Testing & Verification\n- Run `npm test` after any code changes\n- If tests fail, fix the code and re-run\n- Don't skip failing tests\n\n## Code Quality\n- Run linting with `npm run lint:fix` before committing\n- Fix all linting errors before proceeding\n\n## Autonomous Behavior\n- Make decisions independently without asking\n- Commit changes with descriptive messages after verification\n- Always verify fixes work before reporting completion\n```\n\n#### **C. Use Hooks for Deterministic Actions**\n\nHooks guarantee actions happen automatically (unlike relying on Claude's judgment):\n\n```json\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npm run lint:fix\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nThis automatically runs linting after every file editguaranteed, no human needed.\n\n#### **D. Safe Autonomous Mode Flag**\n\nFor **contained workflows** with no internet access:\n\n```bash\nclaude -p \"Run tests and fix all failures\" \\\n  --dangerously-skip-permissions\n```\n\n**WARNING:** Only use in sandboxed environments without internet. This bypasses all permission checks. Prefer pre-approved `--allowedTools` instead for production use.\n\n---\n\n### 3. Headless vs Background Tasks vs Agent Teams\n\n| Feature | Headless Mode | Background Subagents | Agent Teams |\n|---------|---|---|---|\n| **Context Window** | Single shared | Own isolated context | Own contexts (per teammate) |\n| **Execution Style** | Sequential, blocking | Concurrent/parallel | Fully parallel with coordination |\n| **Human Interaction** | Zero required | Zero (pre-approved) | Minimal (lead coordinates) |\n| **Communication** | Direct CLI output | Results returned to main | Direct teammate-to-teammate messaging |\n| **Best For** | Scripts, CI/CD | Parallel research/testing | Complex parallel work requiring negotiation |\n| **Token Cost** | Low | Medium | High (multiple Claude instances) |\n| **Setup Complexity** | Minimal | Medium | High (requires tmux/iTerm2 for split panes) |\n\n**Decision tree:**\n- **Single task, simple workflow**  Use headless mode (`claude -p`)\n- **Task produces verbose output**  Use background subagent\n- **Multiple independent parallel tasks**  Use agent teams\n- **CI/CD pipeline**  Use headless mode + GitHub Actions\n- **Manual parallel experimentation**  Use subagents or Git worktrees\n\n---\n\n### 4. How Hooks Work for Monitoring/Controlling Autonomous Agents\n\nHooks are **deterministic automation**they always run, unlike relying on Claude's judgment.\n\n#### **Common Autonomous Hook Patterns**\n\n**A. Auto-format after file changes**\n```json\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Edit|Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"prettier --write $FILE_PATH\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**B. Block risky operations**\n```bash\n#!/bin/bash\nINPUT=$(cat)\nCOMMAND=$(echo \"$INPUT\" | jq -r '.tool_input.command')\n\n# Prevent database deletions\nif echo \"$COMMAND\" | grep -iE '\\bDROP\\s+TABLE\\b' > /dev/null; then\n  echo \"Blocked: DROP TABLE not allowed\" >&2\n  exit 2\nfi\nexit 0\n```\n\n**C. Run verification after completion**\n```json\n{\n  \"hooks\": {\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"agent\",\n            \"prompt\": \"Verify all unit tests pass. Run the test suite.\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**D. Inject context after compaction**\n```json\n{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"compact\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo 'Reminder: use Bun, not npm. Run tests before committing.'\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**Key Hook Events for Autonomous Monitoring:**\n- `PreToolUse`  Block/allow tools before execution\n- `PostToolUse`  Auto-format, run linters after edits\n- `Stop`  Verify completion conditions\n- `SessionStart`  Re-inject critical context\n- `SubagentStart/Stop`  Monitor subagent lifecycle\n- `Notification`  Send alerts (email, Slack, desktop)\n\n---\n\n### 5. Best Practices for Extended Autonomous Operation\n\n#### **A. Manage Context Proactively**\n\nLong-running autonomous agents must manage context carefully:\n\n```markdown\n# CLAUDE.md\n## For Autonomous Agents\n\n- After every 10 significant changes, summarize progress\n- Use `/compact` with instructions: \"Keep list of modified files and test results\"\n- Don't accumulate irrelevant exploration in context\n- Use subagents for high-volume operations (logging, analysis)\n```\n\n#### **B. Provide Verification Methods**\n\nAutonomous agents work best with explicit success criteria:\n\n```bash\nclaude -p \"Implement the validateEmail function. \nTest with: valid@example.com (true), invalid@.com (false), user (false).\nRun tests and verify all pass before reporting completion.\"\n```\n\n#### **C. Use Subagents for Investigation**\n\nKeep autonomous exploration out of main context:\n\n```bash\nclaude -p \"Use a subagent to investigate the authentication module.\nReport back with findings on token refresh and OAuth utilities.\"\n```\n\n#### **D. Create Focused Skills for Repetitive Tasks**\n\nDefine reusable autonomous workflows in `.claude/skills/`:\n\n```markdown\n---\nname: fix-lint-errors\ndescription: Fix all linting errors in the codebase\ndisable-model-invocation: true\n---\n\n1. Run linting to find errors\n2. Fix each error\n3. Verify all errors are resolved\n4. Report completion\n```\n\nThen invoke autonomously:\n```bash\nclaude -p \"/fix-lint-errors\"\n```\n\n#### **E. Enable Persistent Memory for Long-Running Agents**\n\nFor agents that span multiple sessions:\n\n```yaml\n---\nname: code-reviewer\ndescription: Continuous code quality reviewer\nmemory: user\n---\n\nReview code changes. Update your agent memory with patterns and conventions you discover.\nConsult your memory before starting work to apply learnings from previous reviews.\n```\n\n---\n\n### 6. Scheduling & Triggering Autonomous Agents\n\n#### **A. GitHub Actions Integration**\n\nDeploy Claude Code as an autonomous agent in your CI/CD:\n\n```yaml\nname: AI Code Review\n\non: [pull_request]\n\njobs:\n  review:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: anthropics/claude-code-action@v2\n        with:\n          prompt: |\n            Review this PR for security vulnerabilities.\n            Check token handling, SQL injection, and data exposure.\n          allowed-tools: \"Read,Grep,Glob\"\n          output-format: json\n```\n\n#### **B. GitLab CI/CD**\n\n```yaml\nclaude_review:\n  script:\n    - |\n      claude -p \"Review this merge request for quality issues\" \\\n        --allowedTools \"Read,Grep\" \\\n        --output-format json\n```\n\n#### **C. Cron Jobs / Scheduled Execution**\n\n```bash\n#!/bin/bash\n# Run automated code analysis nightly\n0 2 * * * /usr/local/bin/claude -p \\\n  \"Analyze recent commits for performance regressions\" \\\n  --allowedTools \"Bash(git log *),Bash(npm run benchmark:*)\" \\\n  --output-format json >> /var/log/claude-analysis.log\n```\n\n#### **D. Slack/Discord Integration**\n\nTrigger autonomous agents from messages:\n\n```bash\n#!/bin/bash\n# Trigger from @claude bot in Slack\nif [[ \"$TEXT\" == *\"@claude fix tests\"* ]]; then\n  claude -p \"Fix failing tests. Run test suite and verify all pass.\" \\\n    --allowedTools \"Bash,Edit,Read\"\nfi\n```\n\n---\n\n### 7. Safety Guardrails for Autonomous Execution\n\n**Always configure these before running unattended agents:**\n\n1. **Use Permission Allowlists** (not `--dangerously-skip-permissions`)\n   ```bash\n   claude -p \"...\" --allowedTools \"Read,Bash(npm test:*),Edit\"\n   ```\n\n2. **Enable Sandboxing** for untrusted code\n   ```bash\n   claude --sandbox /sandbox\n   ```\n\n3. **Restrict to Safe Operations**\n   - Use read-only subagents for exploration\n   - Use background tasks for side effects\n   - Use hooks to block risky commands\n\n4. **Monitor Execution**\n   ```bash\n   # Capture output for review\n   claude -p \"...\" --output-format json > /tmp/claude-results.json\n   \n   # Stream for real-time monitoring\n   claude -p \"...\" --output-format stream-json | your_monitoring_tool\n   ```\n\n5. **Test Before Production**\n   - Test autonomous workflow on a branch first\n   - Verify all permissions are correct\n   - Dry-run with `--verbose` before deploying\n\n---\n\n## Quick Reference: Running Autonomous Agents\n\n```bash\n# Simplest: one-off task, headless\nclaude -p \"Fix linting errors\" --allowedTools \"Edit,Bash\"\n\n# With structured output for scripts\nclaude -p \"List API endpoints\" --output-format json | jq '.structured_output.endpoints'\n\n# Continuing previous work\nclaude --continue\n\n# Parallel research with subagents\nclaude -p \"Use subagents to research authentication patterns in parallel\"\n\n# Agent team for complex coordination\nCLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 claude --prompt \"Create a team to review this PR\"\n\n# Scheduled/CI integration\ngh workflow run \"claude-code-action\" -f prompt=\"Analyze recent commits\"\n```\n\n---\n\nFor more details on specific topics:\n- **Scheduling in CI/CD**: See https://code.claude.com/docs/en/github-actions.md\n- **Subagent patterns**: See https://code.claude.com/docs/en/sub-agents.md\n- **Agent teams**: See https://code.claude.com/docs/en/agent-teams.md\n- **Complete hook reference**: See https://code.claude.com/docs/en/hooks.md"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":23646,"cache_creation_input_tokens":10299,"cache_read_input_tokens":22437,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":10299},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CYCVPW3jvgG4qcV5vwZLG","type":"assistant","uuid":"a78ae310-c9fe-4e39-a950-49bdf55095cb","timestamp":"2026-02-16T21:53:35.627Z"}
